/*
Copyright 2022 Upbound Inc.
*/

// Code generated by upjet. DO NOT EDIT.

package v1alpha1

import (
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime/schema"

	v1 "github.com/crossplane/crossplane-runtime/apis/common/v1"
)

type CdromObservation struct {

	// Indicates whether the device should be mapped to a remote client device
	ClientDevice *bool `json:"clientDevice,omitempty" tf:"client_device,omitempty"`

	// The datastore ID the ISO is located on.
	DatastoreID *string `json:"datastoreId,omitempty" tf:"datastore_id,omitempty"`

	// The internally-computed address of this device, such as scsi:0:1, denoting scsi bus #0 and device unit 1.
	DeviceAddress *string `json:"deviceAddress,omitempty" tf:"device_address,omitempty"`

	// The unique device ID for this device within its virtual machine.
	Key *float64 `json:"key,omitempty" tf:"key,omitempty"`

	// The path to the ISO file on the datastore.
	Path *string `json:"path,omitempty" tf:"path,omitempty"`
}

type CdromParameters struct {

	// Indicates whether the device should be mapped to a remote client device
	// +kubebuilder:validation:Optional
	ClientDevice *bool `json:"clientDevice,omitempty" tf:"client_device,omitempty"`

	// The datastore ID the ISO is located on.
	// +kubebuilder:validation:Optional
	DatastoreID *string `json:"datastoreId,omitempty" tf:"datastore_id,omitempty"`

	// The path to the ISO file on the datastore.
	// +kubebuilder:validation:Optional
	Path *string `json:"path,omitempty" tf:"path,omitempty"`
}

type CloneObservation struct {

	// The customization spec for this clone. This allows the user to configure the virtual machine post-clone.
	Customize []CustomizeObservation `json:"customize,omitempty" tf:"customize,omitempty"`

	// Whether or not to create a linked clone when cloning. When this option is used, the source VM must have a single snapshot associated with it.
	LinkedClone *bool `json:"linkedClone,omitempty" tf:"linked_clone,omitempty"`

	// Mapping of ovf networks to the networks to use in vSphere.
	OvfNetworkMap map[string]*string `json:"ovfNetworkMap,omitempty" tf:"ovf_network_map,omitempty"`

	// Mapping of ovf storage to the datastores to use in vSphere.
	OvfStorageMap map[string]*string `json:"ovfStorageMap,omitempty" tf:"ovf_storage_map,omitempty"`

	// The UUID of the source virtual machine or template.
	TemplateUUID *string `json:"templateUuid,omitempty" tf:"template_uuid,omitempty"`

	// The timeout, in minutes, to wait for the virtual machine clone to complete.
	Timeout *float64 `json:"timeout,omitempty" tf:"timeout,omitempty"`
}

type CloneParameters struct {

	// The customization spec for this clone. This allows the user to configure the virtual machine post-clone.
	// +kubebuilder:validation:Optional
	Customize []CustomizeParameters `json:"customize,omitempty" tf:"customize,omitempty"`

	// Whether or not to create a linked clone when cloning. When this option is used, the source VM must have a single snapshot associated with it.
	// +kubebuilder:validation:Optional
	LinkedClone *bool `json:"linkedClone,omitempty" tf:"linked_clone,omitempty"`

	// Mapping of ovf networks to the networks to use in vSphere.
	// +kubebuilder:validation:Optional
	OvfNetworkMap map[string]*string `json:"ovfNetworkMap,omitempty" tf:"ovf_network_map,omitempty"`

	// Mapping of ovf storage to the datastores to use in vSphere.
	// +kubebuilder:validation:Optional
	OvfStorageMap map[string]*string `json:"ovfStorageMap,omitempty" tf:"ovf_storage_map,omitempty"`

	// The UUID of the source virtual machine or template.
	// +kubebuilder:validation:Required
	TemplateUUID *string `json:"templateUuid" tf:"template_uuid,omitempty"`

	// The timeout, in minutes, to wait for the virtual machine clone to complete.
	// +kubebuilder:validation:Optional
	Timeout *float64 `json:"timeout,omitempty" tf:"timeout,omitempty"`
}

type CustomizeObservation struct {

	// The list of DNS servers for a virtual network adapter with a static IP address.
	DNSServerList []*string `json:"dnsServerList,omitempty" tf:"dns_server_list,omitempty"`

	// A list of DNS search domains to add to the DNS configuration on the virtual machine.
	DNSSuffixList []*string `json:"dnsSuffixList,omitempty" tf:"dns_suffix_list,omitempty"`

	// The IPv4 default gateway when using network_interface customization on the virtual machine. This address must be local to a static IPv4 address configured in an interface sub-resource.
	IPv4Gateway *string `json:"ipv4Gateway,omitempty" tf:"ipv4_gateway,omitempty"`

	// The IPv6 default gateway when using network_interface customization on the virtual machine. This address must be local to a static IPv4 address configured in an interface sub-resource.
	IPv6Gateway *string `json:"ipv6Gateway,omitempty" tf:"ipv6_gateway,omitempty"`

	// A list of configuration options specific to Linux virtual machines.
	LinuxOptions []LinuxOptionsObservation `json:"linuxOptions,omitempty" tf:"linux_options,omitempty"`

	// A specification of network interface configuration options.
	NetworkInterface []NetworkInterfaceObservation `json:"networkInterface,omitempty" tf:"network_interface,omitempty"`

	// The amount of time, in minutes, to wait for guest OS customization to complete before returning with an error. Setting this value to 0 or a negative value skips the waiter.
	Timeout *float64 `json:"timeout,omitempty" tf:"timeout,omitempty"`

	// A list of configuration options specific to Windows virtual machines.
	WindowsOptions []WindowsOptionsObservation `json:"windowsOptions,omitempty" tf:"windows_options,omitempty"`
}

type CustomizeParameters struct {

	// The list of DNS servers for a virtual network adapter with a static IP address.
	// +kubebuilder:validation:Optional
	DNSServerList []*string `json:"dnsServerList,omitempty" tf:"dns_server_list,omitempty"`

	// A list of DNS search domains to add to the DNS configuration on the virtual machine.
	// +kubebuilder:validation:Optional
	DNSSuffixList []*string `json:"dnsSuffixList,omitempty" tf:"dns_suffix_list,omitempty"`

	// The IPv4 default gateway when using network_interface customization on the virtual machine. This address must be local to a static IPv4 address configured in an interface sub-resource.
	// +kubebuilder:validation:Optional
	IPv4Gateway *string `json:"ipv4Gateway,omitempty" tf:"ipv4_gateway,omitempty"`

	// The IPv6 default gateway when using network_interface customization on the virtual machine. This address must be local to a static IPv4 address configured in an interface sub-resource.
	// +kubebuilder:validation:Optional
	IPv6Gateway *string `json:"ipv6Gateway,omitempty" tf:"ipv6_gateway,omitempty"`

	// A list of configuration options specific to Linux virtual machines.
	// +kubebuilder:validation:Optional
	LinuxOptions []LinuxOptionsParameters `json:"linuxOptions,omitempty" tf:"linux_options,omitempty"`

	// A specification of network interface configuration options.
	// +kubebuilder:validation:Optional
	NetworkInterface []NetworkInterfaceParameters `json:"networkInterface,omitempty" tf:"network_interface,omitempty"`

	// The amount of time, in minutes, to wait for guest OS customization to complete before returning with an error. Setting this value to 0 or a negative value skips the waiter.
	// +kubebuilder:validation:Optional
	Timeout *float64 `json:"timeout,omitempty" tf:"timeout,omitempty"`

	// A list of configuration options specific to Windows virtual machines.
	// +kubebuilder:validation:Optional
	WindowsOptions []WindowsOptionsParameters `json:"windowsOptions,omitempty" tf:"windows_options,omitempty"`

	// Use this option to specify a windows sysprep file directly.
	// +kubebuilder:validation:Optional
	WindowsSysprepTextSecretRef *v1.SecretKeySelector `json:"windowsSysprepTextSecretRef,omitempty" tf:"-"`
}

type DiskObservation struct {

	// If this is true, the disk is attached instead of created. Implies keep_on_remove.
	Attach *bool `json:"attach,omitempty" tf:"attach,omitempty"`

	// The type of controller the disk should be connected to. Must be 'scsi', 'sata', or 'ide'.
	ControllerType *string `json:"controllerType,omitempty" tf:"controller_type,omitempty"`

	// The datastore ID for this virtual disk, if different than the virtual machine.
	DatastoreID *string `json:"datastoreId,omitempty" tf:"datastore_id,omitempty"`

	// The internally-computed address of this device, such as scsi:0:1, denoting scsi bus #0 and device unit 1.
	DeviceAddress *string `json:"deviceAddress,omitempty" tf:"device_address,omitempty"`

	// The mode of this this virtual disk for purposes of writes and snapshotting. Can be one of append, independent_nonpersistent, independent_persistent, nonpersistent, persistent, or undoable.
	DiskMode *string `json:"diskMode,omitempty" tf:"disk_mode,omitempty"`

	// The sharing mode of this virtual disk. Can be one of sharingMultiWriter or sharingNone.
	DiskSharing *string `json:"diskSharing,omitempty" tf:"disk_sharing,omitempty"`

	// The virtual disk file zeroing policy when thin_provision is not true. The default is false, which lazily-zeros the disk, speeding up thick-provisioned disk creation time.
	EagerlyScrub *bool `json:"eagerlyScrub,omitempty" tf:"eagerly_scrub,omitempty"`

	// The upper limit of IOPS that this disk can use.
	IoLimit *float64 `json:"ioLimit,omitempty" tf:"io_limit,omitempty"`

	// The I/O guarantee that this disk has, in IOPS.
	IoReservation *float64 `json:"ioReservation,omitempty" tf:"io_reservation,omitempty"`

	// The share count for this disk when the share level is custom.
	IoShareCount *float64 `json:"ioShareCount,omitempty" tf:"io_share_count,omitempty"`

	// The share allocation level for this disk. Can be one of low, normal, high, or custom.
	IoShareLevel *string `json:"ioShareLevel,omitempty" tf:"io_share_level,omitempty"`

	// Set to true to keep the underlying VMDK file when removing this virtual disk from configuration.
	KeepOnRemove *bool `json:"keepOnRemove,omitempty" tf:"keep_on_remove,omitempty"`

	// The unique device ID for this device within its virtual machine.
	Key *float64 `json:"key,omitempty" tf:"key,omitempty"`

	// A unique label for this disk.
	Label *string `json:"label,omitempty" tf:"label,omitempty"`

	// The full path of the virtual disk. This can only be provided if attach is set to true, otherwise it is a read-only value.
	Path *string `json:"path,omitempty" tf:"path,omitempty"`

	// The size of the disk, in GB.
	Size *float64 `json:"size,omitempty" tf:"size,omitempty"`

	// The ID of the storage policy to assign to the virtual disk in VM.
	StoragePolicyID *string `json:"storagePolicyId,omitempty" tf:"storage_policy_id,omitempty"`

	// If true, this disk is thin provisioned, with space for the file being allocated on an as-needed basis.
	ThinProvisioned *bool `json:"thinProvisioned,omitempty" tf:"thin_provisioned,omitempty"`

	// The UUID of the virtual disk.
	UUID *string `json:"uuid,omitempty" tf:"uuid,omitempty"`

	// The unique device number for this disk. This number determines where on the SCSI bus this device will be attached.
	UnitNumber *float64 `json:"unitNumber,omitempty" tf:"unit_number,omitempty"`

	// If true, writes for this disk are sent directly to the filesystem immediately instead of being buffered.
	WriteThrough *bool `json:"writeThrough,omitempty" tf:"write_through,omitempty"`
}

type DiskParameters struct {

	// If this is true, the disk is attached instead of created. Implies keep_on_remove.
	// +kubebuilder:validation:Optional
	Attach *bool `json:"attach,omitempty" tf:"attach,omitempty"`

	// The type of controller the disk should be connected to. Must be 'scsi', 'sata', or 'ide'.
	// +kubebuilder:validation:Optional
	ControllerType *string `json:"controllerType,omitempty" tf:"controller_type,omitempty"`

	// The datastore ID for this virtual disk, if different than the virtual machine.
	// +kubebuilder:validation:Optional
	DatastoreID *string `json:"datastoreId,omitempty" tf:"datastore_id,omitempty"`

	// The mode of this this virtual disk for purposes of writes and snapshotting. Can be one of append, independent_nonpersistent, independent_persistent, nonpersistent, persistent, or undoable.
	// +kubebuilder:validation:Optional
	DiskMode *string `json:"diskMode,omitempty" tf:"disk_mode,omitempty"`

	// The sharing mode of this virtual disk. Can be one of sharingMultiWriter or sharingNone.
	// +kubebuilder:validation:Optional
	DiskSharing *string `json:"diskSharing,omitempty" tf:"disk_sharing,omitempty"`

	// The virtual disk file zeroing policy when thin_provision is not true. The default is false, which lazily-zeros the disk, speeding up thick-provisioned disk creation time.
	// +kubebuilder:validation:Optional
	EagerlyScrub *bool `json:"eagerlyScrub,omitempty" tf:"eagerly_scrub,omitempty"`

	// The upper limit of IOPS that this disk can use.
	// +kubebuilder:validation:Optional
	IoLimit *float64 `json:"ioLimit,omitempty" tf:"io_limit,omitempty"`

	// The I/O guarantee that this disk has, in IOPS.
	// +kubebuilder:validation:Optional
	IoReservation *float64 `json:"ioReservation,omitempty" tf:"io_reservation,omitempty"`

	// The share count for this disk when the share level is custom.
	// +kubebuilder:validation:Optional
	IoShareCount *float64 `json:"ioShareCount,omitempty" tf:"io_share_count,omitempty"`

	// The share allocation level for this disk. Can be one of low, normal, high, or custom.
	// +kubebuilder:validation:Optional
	IoShareLevel *string `json:"ioShareLevel,omitempty" tf:"io_share_level,omitempty"`

	// Set to true to keep the underlying VMDK file when removing this virtual disk from configuration.
	// +kubebuilder:validation:Optional
	KeepOnRemove *bool `json:"keepOnRemove,omitempty" tf:"keep_on_remove,omitempty"`

	// A unique label for this disk.
	// +kubebuilder:validation:Required
	Label *string `json:"label" tf:"label,omitempty"`

	// The full path of the virtual disk. This can only be provided if attach is set to true, otherwise it is a read-only value.
	// +kubebuilder:validation:Optional
	Path *string `json:"path,omitempty" tf:"path,omitempty"`

	// The size of the disk, in GB.
	// +kubebuilder:validation:Optional
	Size *float64 `json:"size,omitempty" tf:"size,omitempty"`

	// The ID of the storage policy to assign to the virtual disk in VM.
	// +kubebuilder:validation:Optional
	StoragePolicyID *string `json:"storagePolicyId,omitempty" tf:"storage_policy_id,omitempty"`

	// If true, this disk is thin provisioned, with space for the file being allocated on an as-needed basis.
	// +kubebuilder:validation:Optional
	ThinProvisioned *bool `json:"thinProvisioned,omitempty" tf:"thin_provisioned,omitempty"`

	// The unique device number for this disk. This number determines where on the SCSI bus this device will be attached.
	// +kubebuilder:validation:Optional
	UnitNumber *float64 `json:"unitNumber,omitempty" tf:"unit_number,omitempty"`

	// If true, writes for this disk are sent directly to the filesystem immediately instead of being buffered.
	// +kubebuilder:validation:Optional
	WriteThrough *bool `json:"writeThrough,omitempty" tf:"write_through,omitempty"`
}

type LinuxOptionsObservation struct {

	// The domain name for this virtual machine.
	Domain *string `json:"domain,omitempty" tf:"domain,omitempty"`

	// The hostname for this virtual machine.
	HostName *string `json:"hostName,omitempty" tf:"host_name,omitempty"`

	// Specifies whether or not the hardware clock should be in UTC or not.
	HwClockUtc *bool `json:"hwClockUtc,omitempty" tf:"hw_clock_utc,omitempty"`

	// Customize the time zone on the VM. This should be a time zone-style entry, like America/Los_Angeles.
	TimeZone *string `json:"timeZone,omitempty" tf:"time_zone,omitempty"`
}

type LinuxOptionsParameters struct {

	// The domain name for this virtual machine.
	// +kubebuilder:validation:Required
	Domain *string `json:"domain" tf:"domain,omitempty"`

	// The hostname for this virtual machine.
	// +kubebuilder:validation:Required
	HostName *string `json:"hostName" tf:"host_name,omitempty"`

	// Specifies whether or not the hardware clock should be in UTC or not.
	// +kubebuilder:validation:Optional
	HwClockUtc *bool `json:"hwClockUtc,omitempty" tf:"hw_clock_utc,omitempty"`

	// The customization script to run before and or after guest customization
	// +kubebuilder:validation:Optional
	ScriptTextSecretRef *v1.SecretKeySelector `json:"scriptTextSecretRef,omitempty" tf:"-"`

	// Customize the time zone on the VM. This should be a time zone-style entry, like America/Los_Angeles.
	// +kubebuilder:validation:Optional
	TimeZone *string `json:"timeZone,omitempty" tf:"time_zone,omitempty"`
}

type NetworkInterfaceObservation struct {

	// A DNS search domain to add to the DNS configuration on the virtual machine.
	DNSDomain *string `json:"dnsDomain,omitempty" tf:"dns_domain,omitempty"`

	// Network-interface specific DNS settings for Windows operating systems. Ignored on Linux.
	DNSServerList []*string `json:"dnsServerList,omitempty" tf:"dns_server_list,omitempty"`

	// The IPv4 address assigned to this network adapter. If left blank, DHCP is used.
	IPv4Address *string `json:"ipv4Address,omitempty" tf:"ipv4_address,omitempty"`

	// The IPv4 CIDR netmask for the supplied IP address. Ignored if DHCP is selected.
	IPv4Netmask *float64 `json:"ipv4Netmask,omitempty" tf:"ipv4_netmask,omitempty"`

	// The IPv6 address assigned to this network adapter. If left blank, default auto-configuration is used.
	IPv6Address *string `json:"ipv6Address,omitempty" tf:"ipv6_address,omitempty"`

	// The IPv6 CIDR netmask for the supplied IP address. Ignored if auto-configuration is selected.
	IPv6Netmask *float64 `json:"ipv6Netmask,omitempty" tf:"ipv6_netmask,omitempty"`
}

type NetworkInterfaceParameters struct {

	// A DNS search domain to add to the DNS configuration on the virtual machine.
	// +kubebuilder:validation:Optional
	DNSDomain *string `json:"dnsDomain,omitempty" tf:"dns_domain,omitempty"`

	// Network-interface specific DNS settings for Windows operating systems. Ignored on Linux.
	// +kubebuilder:validation:Optional
	DNSServerList []*string `json:"dnsServerList,omitempty" tf:"dns_server_list,omitempty"`

	// The IPv4 address assigned to this network adapter. If left blank, DHCP is used.
	// +kubebuilder:validation:Optional
	IPv4Address *string `json:"ipv4Address,omitempty" tf:"ipv4_address,omitempty"`

	// The IPv4 CIDR netmask for the supplied IP address. Ignored if DHCP is selected.
	// +kubebuilder:validation:Optional
	IPv4Netmask *float64 `json:"ipv4Netmask,omitempty" tf:"ipv4_netmask,omitempty"`

	// The IPv6 address assigned to this network adapter. If left blank, default auto-configuration is used.
	// +kubebuilder:validation:Optional
	IPv6Address *string `json:"ipv6Address,omitempty" tf:"ipv6_address,omitempty"`

	// The IPv6 CIDR netmask for the supplied IP address. Ignored if auto-configuration is selected.
	// +kubebuilder:validation:Optional
	IPv6Netmask *float64 `json:"ipv6Netmask,omitempty" tf:"ipv6_netmask,omitempty"`
}

type OvfDeployObservation struct {

	// Allow unverified ssl certificates while deploying ovf/ova from url.
	AllowUnverifiedSSLCert *bool `json:"allowUnverifiedSslCert,omitempty" tf:"allow_unverified_ssl_cert,omitempty"`

	// The Deployment option to be chosen. If empty, the default option is used.
	DeploymentOption *string `json:"deploymentOption,omitempty" tf:"deployment_option,omitempty"`

	// An optional disk provisioning. If set, all the disks in the deployed ovf will have the same specified disk type (e.g., thin provisioned).
	DiskProvisioning *string `json:"diskProvisioning,omitempty" tf:"disk_provisioning,omitempty"`

	// Allow properties with ovf:userConfigurable=false to be set.
	EnableHiddenProperties *bool `json:"enableHiddenProperties,omitempty" tf:"enable_hidden_properties,omitempty"`

	// The IP allocation policy.
	IPAllocationPolicy *string `json:"ipAllocationPolicy,omitempty" tf:"ip_allocation_policy,omitempty"`

	// The IP protocol.
	IPProtocol *string `json:"ipProtocol,omitempty" tf:"ip_protocol,omitempty"`

	// The absolute path to the ovf/ova file in the local system.
	LocalOvfPath *string `json:"localOvfPath,omitempty" tf:"local_ovf_path,omitempty"`

	// The mapping of name of network identifiers from the ovf descriptor to network UUID in the VI infrastructure.
	OvfNetworkMap map[string]*string `json:"ovfNetworkMap,omitempty" tf:"ovf_network_map,omitempty"`

	// URL to the remote ovf/ova file to be deployed.
	RemoteOvfURL *string `json:"remoteOvfUrl,omitempty" tf:"remote_ovf_url,omitempty"`
}

type OvfDeployParameters struct {

	// Allow unverified ssl certificates while deploying ovf/ova from url.
	// +kubebuilder:validation:Optional
	AllowUnverifiedSSLCert *bool `json:"allowUnverifiedSslCert,omitempty" tf:"allow_unverified_ssl_cert,omitempty"`

	// The Deployment option to be chosen. If empty, the default option is used.
	// +kubebuilder:validation:Optional
	DeploymentOption *string `json:"deploymentOption,omitempty" tf:"deployment_option,omitempty"`

	// An optional disk provisioning. If set, all the disks in the deployed ovf will have the same specified disk type (e.g., thin provisioned).
	// +kubebuilder:validation:Optional
	DiskProvisioning *string `json:"diskProvisioning,omitempty" tf:"disk_provisioning,omitempty"`

	// Allow properties with ovf:userConfigurable=false to be set.
	// +kubebuilder:validation:Optional
	EnableHiddenProperties *bool `json:"enableHiddenProperties,omitempty" tf:"enable_hidden_properties,omitempty"`

	// The IP allocation policy.
	// +kubebuilder:validation:Optional
	IPAllocationPolicy *string `json:"ipAllocationPolicy,omitempty" tf:"ip_allocation_policy,omitempty"`

	// The IP protocol.
	// +kubebuilder:validation:Optional
	IPProtocol *string `json:"ipProtocol,omitempty" tf:"ip_protocol,omitempty"`

	// The absolute path to the ovf/ova file in the local system.
	// +kubebuilder:validation:Optional
	LocalOvfPath *string `json:"localOvfPath,omitempty" tf:"local_ovf_path,omitempty"`

	// The mapping of name of network identifiers from the ovf descriptor to network UUID in the VI infrastructure.
	// +kubebuilder:validation:Optional
	OvfNetworkMap map[string]*string `json:"ovfNetworkMap,omitempty" tf:"ovf_network_map,omitempty"`

	// URL to the remote ovf/ova file to be deployed.
	// +kubebuilder:validation:Optional
	RemoteOvfURL *string `json:"remoteOvfUrl,omitempty" tf:"remote_ovf_url,omitempty"`
}

type VSphereVirtualMachineNetworkInterfaceObservation struct {

	// The controller type. Can be one of e1000, e1000e, vmxnet3, or vrdma.
	AdapterType *string `json:"adapterType,omitempty" tf:"adapter_type,omitempty"`

	// The upper bandwidth limit of this network interface, in Mbits/sec.
	BandwidthLimit *float64 `json:"bandwidthLimit,omitempty" tf:"bandwidth_limit,omitempty"`

	// The bandwidth reservation of this network interface, in Mbits/sec.
	BandwidthReservation *float64 `json:"bandwidthReservation,omitempty" tf:"bandwidth_reservation,omitempty"`

	// The share count for this network interface when the share level is custom.
	BandwidthShareCount *float64 `json:"bandwidthShareCount,omitempty" tf:"bandwidth_share_count,omitempty"`

	// The bandwidth share allocation level for this interface. Can be one of low, normal, high, or custom.
	BandwidthShareLevel *string `json:"bandwidthShareLevel,omitempty" tf:"bandwidth_share_level,omitempty"`

	// The internally-computed address of this device, such as scsi:0:1, denoting scsi bus #0 and device unit 1.
	DeviceAddress *string `json:"deviceAddress,omitempty" tf:"device_address,omitempty"`

	// The unique device ID for this device within its virtual machine.
	Key *float64 `json:"key,omitempty" tf:"key,omitempty"`

	// The MAC address of this network interface. Can only be manually set if use_static_mac is true.
	MacAddress *string `json:"macAddress,omitempty" tf:"mac_address,omitempty"`

	// The ID of the network to connect this network interface to.
	NetworkID *string `json:"networkId,omitempty" tf:"network_id,omitempty"`

	// Mapping of network interface to OVF network.
	OvfMapping *string `json:"ovfMapping,omitempty" tf:"ovf_mapping,omitempty"`

	// If true, the mac_address field is treated as a static MAC address and set accordingly.
	UseStaticMac *bool `json:"useStaticMac,omitempty" tf:"use_static_mac,omitempty"`
}

type VSphereVirtualMachineNetworkInterfaceParameters struct {

	// The controller type. Can be one of e1000, e1000e, vmxnet3, or vrdma.
	// +kubebuilder:validation:Optional
	AdapterType *string `json:"adapterType,omitempty" tf:"adapter_type,omitempty"`

	// The upper bandwidth limit of this network interface, in Mbits/sec.
	// +kubebuilder:validation:Optional
	BandwidthLimit *float64 `json:"bandwidthLimit,omitempty" tf:"bandwidth_limit,omitempty"`

	// The bandwidth reservation of this network interface, in Mbits/sec.
	// +kubebuilder:validation:Optional
	BandwidthReservation *float64 `json:"bandwidthReservation,omitempty" tf:"bandwidth_reservation,omitempty"`

	// The share count for this network interface when the share level is custom.
	// +kubebuilder:validation:Optional
	BandwidthShareCount *float64 `json:"bandwidthShareCount,omitempty" tf:"bandwidth_share_count,omitempty"`

	// The bandwidth share allocation level for this interface. Can be one of low, normal, high, or custom.
	// +kubebuilder:validation:Optional
	BandwidthShareLevel *string `json:"bandwidthShareLevel,omitempty" tf:"bandwidth_share_level,omitempty"`

	// The MAC address of this network interface. Can only be manually set if use_static_mac is true.
	// +kubebuilder:validation:Optional
	MacAddress *string `json:"macAddress,omitempty" tf:"mac_address,omitempty"`

	// The ID of the network to connect this network interface to.
	// +kubebuilder:validation:Required
	NetworkID *string `json:"networkId" tf:"network_id,omitempty"`

	// Mapping of network interface to OVF network.
	// +kubebuilder:validation:Optional
	OvfMapping *string `json:"ovfMapping,omitempty" tf:"ovf_mapping,omitempty"`

	// If true, the mac_address field is treated as a static MAC address and set accordingly.
	// +kubebuilder:validation:Optional
	UseStaticMac *bool `json:"useStaticMac,omitempty" tf:"use_static_mac,omitempty"`
}

type VSphereVirtualMachineObservation struct {

	// The guest name for the operating system when guest_id is otherGuest or otherGuest64.
	AlternateGuestName *string `json:"alternateGuestName,omitempty" tf:"alternate_guest_name,omitempty"`

	// User-provided description of the virtual machine.
	Annotation *string `json:"annotation,omitempty" tf:"annotation,omitempty"`

	// The number of milliseconds to wait before starting the boot sequence.
	BootDelay *float64 `json:"bootDelay,omitempty" tf:"boot_delay,omitempty"`

	// The number of milliseconds to wait before retrying the boot sequence. This only valid if boot_retry_enabled is true.
	BootRetryDelay *float64 `json:"bootRetryDelay,omitempty" tf:"boot_retry_delay,omitempty"`

	// If set to true, a virtual machine that fails to boot will try again after the delay defined in boot_retry_delay.
	BootRetryEnabled *bool `json:"bootRetryEnabled,omitempty" tf:"boot_retry_enabled,omitempty"`

	// Allow CPUs to be added to this virtual machine while it is running.
	CPUHotAddEnabled *bool `json:"cpuHotAddEnabled,omitempty" tf:"cpu_hot_add_enabled,omitempty"`

	// Allow CPUs to be added to this virtual machine while it is running.
	CPUHotRemoveEnabled *bool `json:"cpuHotRemoveEnabled,omitempty" tf:"cpu_hot_remove_enabled,omitempty"`

	// The maximum amount of memory (in MB) or CPU (in MHz) that this virtual machine can consume, regardless of available resources.
	CPULimit *float64 `json:"cpuLimit,omitempty" tf:"cpu_limit,omitempty"`

	// Enable CPU performance counters on this virtual machine.
	CPUPerformanceCountersEnabled *bool `json:"cpuPerformanceCountersEnabled,omitempty" tf:"cpu_performance_counters_enabled,omitempty"`

	// The amount of memory (in MB) or CPU (in MHz) that this virtual machine is guaranteed.
	CPUReservation *float64 `json:"cpuReservation,omitempty" tf:"cpu_reservation,omitempty"`

	// The amount of shares to allocate to cpu for a custom share level.
	CPUShareCount *float64 `json:"cpuShareCount,omitempty" tf:"cpu_share_count,omitempty"`

	// The allocation level for cpu resources. Can be one of high, low, normal, or custom.
	CPUShareLevel *string `json:"cpuShareLevel,omitempty" tf:"cpu_share_level,omitempty"`

	// A specification for a CDROM device on this virtual machine.
	Cdrom []CdromObservation `json:"cdrom,omitempty" tf:"cdrom,omitempty"`

	// A unique identifier for a given version of the last configuration applied, such the timestamp of the last update to the configuration.
	ChangeVersion *string `json:"changeVersion,omitempty" tf:"change_version,omitempty"`

	// A specification for cloning a virtual machine from template.
	Clone []CloneObservation `json:"clone,omitempty" tf:"clone,omitempty"`

	// A list of custom attributes to set on this resource.
	CustomAttributes map[string]*string `json:"customAttributes,omitempty" tf:"custom_attributes,omitempty"`

	// The ID of the datacenter where the VM is to be created.
	DatacenterID *string `json:"datacenterId,omitempty" tf:"datacenter_id,omitempty"`

	// The ID of a datastore cluster to put the virtual machine in.
	DatastoreClusterID *string `json:"datastoreClusterId,omitempty" tf:"datastore_cluster_id,omitempty"`

	// The ID of the virtual machine's datastore. The virtual machine configuration is placed here, along with any virtual disks that are created without datastores.
	DatastoreID *string `json:"datastoreId,omitempty" tf:"datastore_id,omitempty"`

	DefaultIPAddress *string `json:"defaultIpAddress,omitempty" tf:"default_ip_address,omitempty"`

	// A specification for a virtual disk device on this virtual machine.
	Disk []DiskObservation `json:"disk,omitempty" tf:"disk,omitempty"`

	// When the boot type set in firmware is efi, this enables EFI secure boot.
	EfiSecureBootEnabled *bool `json:"efiSecureBootEnabled,omitempty" tf:"efi_secure_boot_enabled,omitempty"`

	// Expose the UUIDs of attached virtual disks to the virtual machine, allowing access to them in the guest.
	EnableDiskUUID *bool `json:"enableDiskUuid,omitempty" tf:"enable_disk_uuid,omitempty"`

	// Enable logging on this virtual machine.
	EnableLogging *bool `json:"enableLogging,omitempty" tf:"enable_logging,omitempty"`

	// The EPT/RVI (hardware memory virtualization) setting for this virtual machine. Can be one of automatic, on, or off.
	EptRviMode *string `json:"eptRviMode,omitempty" tf:"ept_rvi_mode,omitempty"`

	// Extra configuration data for this virtual machine. Can be used to supply advanced parameters not normally in configuration, such as instance metadata, or configuration data for OVF images.
	ExtraConfig map[string]*string `json:"extraConfig,omitempty" tf:"extra_config,omitempty"`

	// Allow the virtual machine to be rebooted when a change to `extra_config` occurs.
	ExtraConfigRebootRequired *bool `json:"extraConfigRebootRequired,omitempty" tf:"extra_config_reboot_required,omitempty"`

	// The firmware interface to use on the virtual machine. Can be one of bios or efi.
	Firmware *string `json:"firmware,omitempty" tf:"firmware,omitempty"`

	// The name of the folder to locate the virtual machine in.
	Folder *string `json:"folder,omitempty" tf:"folder,omitempty"`

	// Set to true to force power-off a virtual machine if a graceful guest shutdown failed for a necessary operation.
	ForcePowerOff *bool `json:"forcePowerOff,omitempty" tf:"force_power_off,omitempty"`

	// The guest ID for the operating system.
	GuestID *string `json:"guestId,omitempty" tf:"guest_id,omitempty"`

	// The current list of IP addresses on this virtual machine.
	GuestIPAddresses []*string `json:"guestIpAddresses,omitempty" tf:"guest_ip_addresses,omitempty"`

	// The hardware version for the virtual machine.
	HardwareVersion *float64 `json:"hardwareVersion,omitempty" tf:"hardware_version,omitempty"`

	// The ID of an optional host system to pin the virtual machine to.
	HostSystemID *string `json:"hostSystemId,omitempty" tf:"host_system_id,omitempty"`

	// The (non-nested) hardware virtualization setting for this virtual machine. Can be one of hvAuto, hvOn, or hvOff.
	HvMode *string `json:"hvMode,omitempty" tf:"hv_mode,omitempty"`

	ID *string `json:"id,omitempty" tf:"id,omitempty"`

	// This directly affects the amount of disks you can add to the virtual machine and the maximum disk unit number. Note that lowering this value does not remove controllers.
	IdeControllerCount *float64 `json:"ideControllerCount,omitempty" tf:"ide_controller_count,omitempty"`

	// List of IP addresses and CIDR networks to ignore while waiting for an IP
	IgnoredGuestIps []*string `json:"ignoredGuestIps,omitempty" tf:"ignored_guest_ips,omitempty"`

	// Reset after the first post-import or post-upgrade apply.
	Imported *bool `json:"imported,omitempty" tf:"imported,omitempty"`

	// Controls the scheduling delay of the virtual machine. Use a higher sensitivity for applications that require lower latency, such as VOIP, media player applications, or applications that require frequent access to mouse or keyboard devices. Can be one of low, normal, medium, or high.
	LatencySensitivity *string `json:"latencySensitivity,omitempty" tf:"latency_sensitivity,omitempty"`

	// The size of the virtual machine's memory, in MB.
	Memory *float64 `json:"memory,omitempty" tf:"memory,omitempty"`

	// Allow memory to be added to this virtual machine while it is running.
	MemoryHotAddEnabled *bool `json:"memoryHotAddEnabled,omitempty" tf:"memory_hot_add_enabled,omitempty"`

	// The maximum amount of memory (in MB) or CPU (in MHz) that this virtual machine can consume, regardless of available resources.
	MemoryLimit *float64 `json:"memoryLimit,omitempty" tf:"memory_limit,omitempty"`

	// The amount of memory (in MB) or CPU (in MHz) that this virtual machine is guaranteed.
	MemoryReservation *float64 `json:"memoryReservation,omitempty" tf:"memory_reservation,omitempty"`

	// The amount of shares to allocate to memory for a custom share level.
	MemoryShareCount *float64 `json:"memoryShareCount,omitempty" tf:"memory_share_count,omitempty"`

	// The allocation level for memory resources. Can be one of high, low, normal, or custom.
	MemoryShareLevel *string `json:"memoryShareLevel,omitempty" tf:"memory_share_level,omitempty"`

	// The amount of time, in minutes, to wait for a vMotion operation to complete before failing.
	MigrateWaitTimeout *float64 `json:"migrateWaitTimeout,omitempty" tf:"migrate_wait_timeout,omitempty"`

	// The machine object ID from VMware vSphere.
	Moid *string `json:"moid,omitempty" tf:"moid,omitempty"`

	// The name of this virtual machine.
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// Enable nested hardware virtualization on this virtual machine, facilitating nested virtualization in the guest.
	NestedHvEnabled *bool `json:"nestedHvEnabled,omitempty" tf:"nested_hv_enabled,omitempty"`

	// A specification for a virtual NIC on this virtual machine.
	NetworkInterface []VSphereVirtualMachineNetworkInterfaceObservation `json:"networkInterface,omitempty" tf:"network_interface,omitempty"`

	// The number of cores to distribute amongst the CPUs in this virtual machine. If specified, the value supplied to num_cpus must be evenly divisible by this value.
	NumCoresPerSocket *float64 `json:"numCoresPerSocket,omitempty" tf:"num_cores_per_socket,omitempty"`

	// The number of virtual processors to assign to this virtual machine.
	NumCpus *float64 `json:"numCpus,omitempty" tf:"num_cpus,omitempty"`

	// A specification for deploying a virtual machine from ovf/ova template.
	OvfDeploy []OvfDeployObservation `json:"ovfDeploy,omitempty" tf:"ovf_deploy,omitempty"`

	// A list of PCI passthrough devices
	PciDeviceID []*string `json:"pciDeviceId,omitempty" tf:"pci_device_id,omitempty"`

	// The power state of the virtual machine.
	PowerState *string `json:"powerState,omitempty" tf:"power_state,omitempty"`

	// The amount of time, in seconds, that we will be trying to power on a VM
	PoweronTimeout *float64 `json:"poweronTimeout,omitempty" tf:"poweron_timeout,omitempty"`

	RebootRequired *bool `json:"rebootRequired,omitempty" tf:"reboot_required,omitempty"`

	// Triggers replacement of resource whenever it changes.
	ReplaceTrigger *string `json:"replaceTrigger,omitempty" tf:"replace_trigger,omitempty"`

	// The ID of a resource pool to put the virtual machine in.
	ResourcePoolID *string `json:"resourcePoolId,omitempty" tf:"resource_pool_id,omitempty"`

	// Enable the run of scripts after virtual machine power-on when VMware Tools is installed.
	RunToolsScriptsAfterPowerOn *bool `json:"runToolsScriptsAfterPowerOn,omitempty" tf:"run_tools_scripts_after_power_on,omitempty"`

	// Enable the run of scripts after virtual machine resume when when VMware Tools is installed.
	RunToolsScriptsAfterResume *bool `json:"runToolsScriptsAfterResume,omitempty" tf:"run_tools_scripts_after_resume,omitempty"`

	// Enable the run of scripts before guest operating system reboot when VMware Tools is installed.
	RunToolsScriptsBeforeGuestReboot *bool `json:"runToolsScriptsBeforeGuestReboot,omitempty" tf:"run_tools_scripts_before_guest_reboot,omitempty"`

	// Enable the run of scripts before guest operating system shutdown when VMware Tools is installed.
	RunToolsScriptsBeforeGuestShutdown *bool `json:"runToolsScriptsBeforeGuestShutdown,omitempty" tf:"run_tools_scripts_before_guest_shutdown,omitempty"`

	// Enable the run of scripts before guest operating system standby when VMware Tools is installed.
	RunToolsScriptsBeforeGuestStandby *bool `json:"runToolsScriptsBeforeGuestStandby,omitempty" tf:"run_tools_scripts_before_guest_standby,omitempty"`

	// This directly affects the amount of disks you can add to the virtual machine and the maximum disk unit number. Note that lowering this value does not remove controllers.
	SataControllerCount *float64 `json:"sataControllerCount,omitempty" tf:"sata_controller_count,omitempty"`

	// Mode for sharing the SCSI bus. The modes are physicalSharing, virtualSharing, and noSharing.
	ScsiBusSharing *string `json:"scsiBusSharing,omitempty" tf:"scsi_bus_sharing,omitempty"`

	// This directly affects the amount of disks you can add to the virtual machine and the maximum disk unit number. Note that lowering this value does not remove controllers.
	ScsiControllerCount *float64 `json:"scsiControllerCount,omitempty" tf:"scsi_controller_count,omitempty"`

	// The type of SCSI bus this virtual machine will have. Can be one of lsilogic, lsilogic-sas or pvscsi.
	ScsiType *string `json:"scsiType,omitempty" tf:"scsi_type,omitempty"`

	// The amount of time, in minutes, to wait for shutdown when making necessary updates to the virtual machine.
	ShutdownWaitTimeout *float64 `json:"shutdownWaitTimeout,omitempty" tf:"shutdown_wait_timeout,omitempty"`

	// The ID of the storage policy to assign to the virtual machine home directory.
	StoragePolicyID *string `json:"storagePolicyId,omitempty" tf:"storage_policy_id,omitempty"`

	// The swap file placement policy for this virtual machine. Can be one of inherit, hostLocal, or vmDirectory.
	SwapPlacementPolicy *string `json:"swapPlacementPolicy,omitempty" tf:"swap_placement_policy,omitempty"`

	// Enable guest clock synchronization with the host. On vSphere 7.0 U1 and above, with only this setting the clock is synchronized on startup and resume. Requires VMware Tools to be installed.
	SyncTimeWithHost *bool `json:"syncTimeWithHost,omitempty" tf:"sync_time_with_host,omitempty"`

	// Enable periodic clock synchronization with the host. Supported only on vSphere 7.0 U1 and above. On prior versions setting `sync_time_with_host` is enough for periodic synchronization. Requires VMware Tools to be installed.
	SyncTimeWithHostPeriodically *bool `json:"syncTimeWithHostPeriodically,omitempty" tf:"sync_time_with_host_periodically,omitempty"`

	// A list of tag IDs to apply to this object.
	Tags []*string `json:"tags,omitempty" tf:"tags,omitempty"`

	// Set the upgrade policy for VMware Tools. Can be one of `manual` or `upgradeAtPowerCycle`.
	ToolsUpgradePolicy *string `json:"toolsUpgradePolicy,omitempty" tf:"tools_upgrade_policy,omitempty"`

	// The UUID of the virtual machine. Also exposed as the ID of the resource.
	UUID *string `json:"uuid,omitempty" tf:"uuid,omitempty"`

	// vApp configuration data for this virtual machine. Can be used to provide configuration data for OVF images.
	Vapp []VappObservation `json:"vapp,omitempty" tf:"vapp,omitempty"`

	// vApp transport methods supported by virtual machine.
	VappTransport []*string `json:"vappTransport,omitempty" tf:"vapp_transport,omitempty"`

	// Flag to specify if Virtualization-based security is enabled for this virtual machine.
	VbsEnabled *bool `json:"vbsEnabled,omitempty" tf:"vbs_enabled,omitempty"`

	// The state of VMware Tools in the guest. This will determine the proper course of action for some device operations.
	VmwareToolsStatus *string `json:"vmwareToolsStatus,omitempty" tf:"vmware_tools_status,omitempty"`

	// The path of the virtual machine's configuration file in the VM's datastore.
	VmxPath *string `json:"vmxPath,omitempty" tf:"vmx_path,omitempty"`

	// Flag to specify if I/O MMU virtualization, also called Intel Virtualization Technology for Directed I/O (VT-d) and AMD I/O Virtualization (AMD-Vi or IOMMU), is enabled.
	VvtdEnabled *bool `json:"vvtdEnabled,omitempty" tf:"vvtd_enabled,omitempty"`

	// The amount of time, in minutes, to wait for an available IP address on this virtual machine. A value less than 1 disables the waiter.
	WaitForGuestIPTimeout *float64 `json:"waitForGuestIpTimeout,omitempty" tf:"wait_for_guest_ip_timeout,omitempty"`

	// Controls whether or not the guest network waiter waits for a routable address. When false, the waiter does not wait for a default gateway, nor are IP addresses checked against any discovered default gateways as part of its success criteria.
	WaitForGuestNetRoutable *bool `json:"waitForGuestNetRoutable,omitempty" tf:"wait_for_guest_net_routable,omitempty"`

	// The amount of time, in minutes, to wait for an available IP address on this virtual machine. A value less than 1 disables the waiter.
	WaitForGuestNetTimeout *float64 `json:"waitForGuestNetTimeout,omitempty" tf:"wait_for_guest_net_timeout,omitempty"`
}

type VSphereVirtualMachineParameters struct {

	// The guest name for the operating system when guest_id is otherGuest or otherGuest64.
	// +kubebuilder:validation:Optional
	AlternateGuestName *string `json:"alternateGuestName,omitempty" tf:"alternate_guest_name,omitempty"`

	// User-provided description of the virtual machine.
	// +kubebuilder:validation:Optional
	Annotation *string `json:"annotation,omitempty" tf:"annotation,omitempty"`

	// The number of milliseconds to wait before starting the boot sequence.
	// +kubebuilder:validation:Optional
	BootDelay *float64 `json:"bootDelay,omitempty" tf:"boot_delay,omitempty"`

	// The number of milliseconds to wait before retrying the boot sequence. This only valid if boot_retry_enabled is true.
	// +kubebuilder:validation:Optional
	BootRetryDelay *float64 `json:"bootRetryDelay,omitempty" tf:"boot_retry_delay,omitempty"`

	// If set to true, a virtual machine that fails to boot will try again after the delay defined in boot_retry_delay.
	// +kubebuilder:validation:Optional
	BootRetryEnabled *bool `json:"bootRetryEnabled,omitempty" tf:"boot_retry_enabled,omitempty"`

	// Allow CPUs to be added to this virtual machine while it is running.
	// +kubebuilder:validation:Optional
	CPUHotAddEnabled *bool `json:"cpuHotAddEnabled,omitempty" tf:"cpu_hot_add_enabled,omitempty"`

	// Allow CPUs to be added to this virtual machine while it is running.
	// +kubebuilder:validation:Optional
	CPUHotRemoveEnabled *bool `json:"cpuHotRemoveEnabled,omitempty" tf:"cpu_hot_remove_enabled,omitempty"`

	// The maximum amount of memory (in MB) or CPU (in MHz) that this virtual machine can consume, regardless of available resources.
	// +kubebuilder:validation:Optional
	CPULimit *float64 `json:"cpuLimit,omitempty" tf:"cpu_limit,omitempty"`

	// Enable CPU performance counters on this virtual machine.
	// +kubebuilder:validation:Optional
	CPUPerformanceCountersEnabled *bool `json:"cpuPerformanceCountersEnabled,omitempty" tf:"cpu_performance_counters_enabled,omitempty"`

	// The amount of memory (in MB) or CPU (in MHz) that this virtual machine is guaranteed.
	// +kubebuilder:validation:Optional
	CPUReservation *float64 `json:"cpuReservation,omitempty" tf:"cpu_reservation,omitempty"`

	// The amount of shares to allocate to cpu for a custom share level.
	// +kubebuilder:validation:Optional
	CPUShareCount *float64 `json:"cpuShareCount,omitempty" tf:"cpu_share_count,omitempty"`

	// The allocation level for cpu resources. Can be one of high, low, normal, or custom.
	// +kubebuilder:validation:Optional
	CPUShareLevel *string `json:"cpuShareLevel,omitempty" tf:"cpu_share_level,omitempty"`

	// A specification for a CDROM device on this virtual machine.
	// +kubebuilder:validation:Optional
	Cdrom []CdromParameters `json:"cdrom,omitempty" tf:"cdrom,omitempty"`

	// A specification for cloning a virtual machine from template.
	// +kubebuilder:validation:Optional
	Clone []CloneParameters `json:"clone,omitempty" tf:"clone,omitempty"`

	// A list of custom attributes to set on this resource.
	// +kubebuilder:validation:Optional
	CustomAttributes map[string]*string `json:"customAttributes,omitempty" tf:"custom_attributes,omitempty"`

	// The ID of the datacenter where the VM is to be created.
	// +kubebuilder:validation:Optional
	DatacenterID *string `json:"datacenterId,omitempty" tf:"datacenter_id,omitempty"`

	// The ID of a datastore cluster to put the virtual machine in.
	// +kubebuilder:validation:Optional
	DatastoreClusterID *string `json:"datastoreClusterId,omitempty" tf:"datastore_cluster_id,omitempty"`

	// The ID of the virtual machine's datastore. The virtual machine configuration is placed here, along with any virtual disks that are created without datastores.
	// +kubebuilder:validation:Optional
	DatastoreID *string `json:"datastoreId,omitempty" tf:"datastore_id,omitempty"`

	// A specification for a virtual disk device on this virtual machine.
	// +kubebuilder:validation:Optional
	Disk []DiskParameters `json:"disk,omitempty" tf:"disk,omitempty"`

	// When the boot type set in firmware is efi, this enables EFI secure boot.
	// +kubebuilder:validation:Optional
	EfiSecureBootEnabled *bool `json:"efiSecureBootEnabled,omitempty" tf:"efi_secure_boot_enabled,omitempty"`

	// Expose the UUIDs of attached virtual disks to the virtual machine, allowing access to them in the guest.
	// +kubebuilder:validation:Optional
	EnableDiskUUID *bool `json:"enableDiskUuid,omitempty" tf:"enable_disk_uuid,omitempty"`

	// Enable logging on this virtual machine.
	// +kubebuilder:validation:Optional
	EnableLogging *bool `json:"enableLogging,omitempty" tf:"enable_logging,omitempty"`

	// The EPT/RVI (hardware memory virtualization) setting for this virtual machine. Can be one of automatic, on, or off.
	// +kubebuilder:validation:Optional
	EptRviMode *string `json:"eptRviMode,omitempty" tf:"ept_rvi_mode,omitempty"`

	// Extra configuration data for this virtual machine. Can be used to supply advanced parameters not normally in configuration, such as instance metadata, or configuration data for OVF images.
	// +kubebuilder:validation:Optional
	ExtraConfig map[string]*string `json:"extraConfig,omitempty" tf:"extra_config,omitempty"`

	// Allow the virtual machine to be rebooted when a change to `extra_config` occurs.
	// +kubebuilder:validation:Optional
	ExtraConfigRebootRequired *bool `json:"extraConfigRebootRequired,omitempty" tf:"extra_config_reboot_required,omitempty"`

	// The firmware interface to use on the virtual machine. Can be one of bios or efi.
	// +kubebuilder:validation:Optional
	Firmware *string `json:"firmware,omitempty" tf:"firmware,omitempty"`

	// The name of the folder to locate the virtual machine in.
	// +kubebuilder:validation:Optional
	Folder *string `json:"folder,omitempty" tf:"folder,omitempty"`

	// Set to true to force power-off a virtual machine if a graceful guest shutdown failed for a necessary operation.
	// +kubebuilder:validation:Optional
	ForcePowerOff *bool `json:"forcePowerOff,omitempty" tf:"force_power_off,omitempty"`

	// The guest ID for the operating system.
	// +kubebuilder:validation:Optional
	GuestID *string `json:"guestId,omitempty" tf:"guest_id,omitempty"`

	// The hardware version for the virtual machine.
	// +kubebuilder:validation:Optional
	HardwareVersion *float64 `json:"hardwareVersion,omitempty" tf:"hardware_version,omitempty"`

	// The ID of an optional host system to pin the virtual machine to.
	// +kubebuilder:validation:Optional
	HostSystemID *string `json:"hostSystemId,omitempty" tf:"host_system_id,omitempty"`

	// The (non-nested) hardware virtualization setting for this virtual machine. Can be one of hvAuto, hvOn, or hvOff.
	// +kubebuilder:validation:Optional
	HvMode *string `json:"hvMode,omitempty" tf:"hv_mode,omitempty"`

	// This directly affects the amount of disks you can add to the virtual machine and the maximum disk unit number. Note that lowering this value does not remove controllers.
	// +kubebuilder:validation:Optional
	IdeControllerCount *float64 `json:"ideControllerCount,omitempty" tf:"ide_controller_count,omitempty"`

	// List of IP addresses and CIDR networks to ignore while waiting for an IP
	// +kubebuilder:validation:Optional
	IgnoredGuestIps []*string `json:"ignoredGuestIps,omitempty" tf:"ignored_guest_ips,omitempty"`

	// Controls the scheduling delay of the virtual machine. Use a higher sensitivity for applications that require lower latency, such as VOIP, media player applications, or applications that require frequent access to mouse or keyboard devices. Can be one of low, normal, medium, or high.
	// +kubebuilder:validation:Optional
	LatencySensitivity *string `json:"latencySensitivity,omitempty" tf:"latency_sensitivity,omitempty"`

	// The size of the virtual machine's memory, in MB.
	// +kubebuilder:validation:Optional
	Memory *float64 `json:"memory,omitempty" tf:"memory,omitempty"`

	// Allow memory to be added to this virtual machine while it is running.
	// +kubebuilder:validation:Optional
	MemoryHotAddEnabled *bool `json:"memoryHotAddEnabled,omitempty" tf:"memory_hot_add_enabled,omitempty"`

	// The maximum amount of memory (in MB) or CPU (in MHz) that this virtual machine can consume, regardless of available resources.
	// +kubebuilder:validation:Optional
	MemoryLimit *float64 `json:"memoryLimit,omitempty" tf:"memory_limit,omitempty"`

	// The amount of memory (in MB) or CPU (in MHz) that this virtual machine is guaranteed.
	// +kubebuilder:validation:Optional
	MemoryReservation *float64 `json:"memoryReservation,omitempty" tf:"memory_reservation,omitempty"`

	// The amount of shares to allocate to memory for a custom share level.
	// +kubebuilder:validation:Optional
	MemoryShareCount *float64 `json:"memoryShareCount,omitempty" tf:"memory_share_count,omitempty"`

	// The allocation level for memory resources. Can be one of high, low, normal, or custom.
	// +kubebuilder:validation:Optional
	MemoryShareLevel *string `json:"memoryShareLevel,omitempty" tf:"memory_share_level,omitempty"`

	// The amount of time, in minutes, to wait for a vMotion operation to complete before failing.
	// +kubebuilder:validation:Optional
	MigrateWaitTimeout *float64 `json:"migrateWaitTimeout,omitempty" tf:"migrate_wait_timeout,omitempty"`

	// The name of this virtual machine.
	// +kubebuilder:validation:Optional
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// Enable nested hardware virtualization on this virtual machine, facilitating nested virtualization in the guest.
	// +kubebuilder:validation:Optional
	NestedHvEnabled *bool `json:"nestedHvEnabled,omitempty" tf:"nested_hv_enabled,omitempty"`

	// A specification for a virtual NIC on this virtual machine.
	// +kubebuilder:validation:Optional
	NetworkInterface []VSphereVirtualMachineNetworkInterfaceParameters `json:"networkInterface,omitempty" tf:"network_interface,omitempty"`

	// The number of cores to distribute amongst the CPUs in this virtual machine. If specified, the value supplied to num_cpus must be evenly divisible by this value.
	// +kubebuilder:validation:Optional
	NumCoresPerSocket *float64 `json:"numCoresPerSocket,omitempty" tf:"num_cores_per_socket,omitempty"`

	// The number of virtual processors to assign to this virtual machine.
	// +kubebuilder:validation:Optional
	NumCpus *float64 `json:"numCpus,omitempty" tf:"num_cpus,omitempty"`

	// A specification for deploying a virtual machine from ovf/ova template.
	// +kubebuilder:validation:Optional
	OvfDeploy []OvfDeployParameters `json:"ovfDeploy,omitempty" tf:"ovf_deploy,omitempty"`

	// A list of PCI passthrough devices
	// +kubebuilder:validation:Optional
	PciDeviceID []*string `json:"pciDeviceId,omitempty" tf:"pci_device_id,omitempty"`

	// The amount of time, in seconds, that we will be trying to power on a VM
	// +kubebuilder:validation:Optional
	PoweronTimeout *float64 `json:"poweronTimeout,omitempty" tf:"poweron_timeout,omitempty"`

	// Triggers replacement of resource whenever it changes.
	// +kubebuilder:validation:Optional
	ReplaceTrigger *string `json:"replaceTrigger,omitempty" tf:"replace_trigger,omitempty"`

	// The ID of a resource pool to put the virtual machine in.
	// +kubebuilder:validation:Optional
	ResourcePoolID *string `json:"resourcePoolId,omitempty" tf:"resource_pool_id,omitempty"`

	// Enable the run of scripts after virtual machine power-on when VMware Tools is installed.
	// +kubebuilder:validation:Optional
	RunToolsScriptsAfterPowerOn *bool `json:"runToolsScriptsAfterPowerOn,omitempty" tf:"run_tools_scripts_after_power_on,omitempty"`

	// Enable the run of scripts after virtual machine resume when when VMware Tools is installed.
	// +kubebuilder:validation:Optional
	RunToolsScriptsAfterResume *bool `json:"runToolsScriptsAfterResume,omitempty" tf:"run_tools_scripts_after_resume,omitempty"`

	// Enable the run of scripts before guest operating system reboot when VMware Tools is installed.
	// +kubebuilder:validation:Optional
	RunToolsScriptsBeforeGuestReboot *bool `json:"runToolsScriptsBeforeGuestReboot,omitempty" tf:"run_tools_scripts_before_guest_reboot,omitempty"`

	// Enable the run of scripts before guest operating system shutdown when VMware Tools is installed.
	// +kubebuilder:validation:Optional
	RunToolsScriptsBeforeGuestShutdown *bool `json:"runToolsScriptsBeforeGuestShutdown,omitempty" tf:"run_tools_scripts_before_guest_shutdown,omitempty"`

	// Enable the run of scripts before guest operating system standby when VMware Tools is installed.
	// +kubebuilder:validation:Optional
	RunToolsScriptsBeforeGuestStandby *bool `json:"runToolsScriptsBeforeGuestStandby,omitempty" tf:"run_tools_scripts_before_guest_standby,omitempty"`

	// This directly affects the amount of disks you can add to the virtual machine and the maximum disk unit number. Note that lowering this value does not remove controllers.
	// +kubebuilder:validation:Optional
	SataControllerCount *float64 `json:"sataControllerCount,omitempty" tf:"sata_controller_count,omitempty"`

	// Mode for sharing the SCSI bus. The modes are physicalSharing, virtualSharing, and noSharing.
	// +kubebuilder:validation:Optional
	ScsiBusSharing *string `json:"scsiBusSharing,omitempty" tf:"scsi_bus_sharing,omitempty"`

	// This directly affects the amount of disks you can add to the virtual machine and the maximum disk unit number. Note that lowering this value does not remove controllers.
	// +kubebuilder:validation:Optional
	ScsiControllerCount *float64 `json:"scsiControllerCount,omitempty" tf:"scsi_controller_count,omitempty"`

	// The type of SCSI bus this virtual machine will have. Can be one of lsilogic, lsilogic-sas or pvscsi.
	// +kubebuilder:validation:Optional
	ScsiType *string `json:"scsiType,omitempty" tf:"scsi_type,omitempty"`

	// The amount of time, in minutes, to wait for shutdown when making necessary updates to the virtual machine.
	// +kubebuilder:validation:Optional
	ShutdownWaitTimeout *float64 `json:"shutdownWaitTimeout,omitempty" tf:"shutdown_wait_timeout,omitempty"`

	// The ID of the storage policy to assign to the virtual machine home directory.
	// +kubebuilder:validation:Optional
	StoragePolicyID *string `json:"storagePolicyId,omitempty" tf:"storage_policy_id,omitempty"`

	// The swap file placement policy for this virtual machine. Can be one of inherit, hostLocal, or vmDirectory.
	// +kubebuilder:validation:Optional
	SwapPlacementPolicy *string `json:"swapPlacementPolicy,omitempty" tf:"swap_placement_policy,omitempty"`

	// Enable guest clock synchronization with the host. On vSphere 7.0 U1 and above, with only this setting the clock is synchronized on startup and resume. Requires VMware Tools to be installed.
	// +kubebuilder:validation:Optional
	SyncTimeWithHost *bool `json:"syncTimeWithHost,omitempty" tf:"sync_time_with_host,omitempty"`

	// Enable periodic clock synchronization with the host. Supported only on vSphere 7.0 U1 and above. On prior versions setting `sync_time_with_host` is enough for periodic synchronization. Requires VMware Tools to be installed.
	// +kubebuilder:validation:Optional
	SyncTimeWithHostPeriodically *bool `json:"syncTimeWithHostPeriodically,omitempty" tf:"sync_time_with_host_periodically,omitempty"`

	// A list of tag IDs to apply to this object.
	// +kubebuilder:validation:Optional
	Tags []*string `json:"tags,omitempty" tf:"tags,omitempty"`

	// Set the upgrade policy for VMware Tools. Can be one of `manual` or `upgradeAtPowerCycle`.
	// +kubebuilder:validation:Optional
	ToolsUpgradePolicy *string `json:"toolsUpgradePolicy,omitempty" tf:"tools_upgrade_policy,omitempty"`

	// vApp configuration data for this virtual machine. Can be used to provide configuration data for OVF images.
	// +kubebuilder:validation:Optional
	Vapp []VappParameters `json:"vapp,omitempty" tf:"vapp,omitempty"`

	// Flag to specify if Virtualization-based security is enabled for this virtual machine.
	// +kubebuilder:validation:Optional
	VbsEnabled *bool `json:"vbsEnabled,omitempty" tf:"vbs_enabled,omitempty"`

	// Flag to specify if I/O MMU virtualization, also called Intel Virtualization Technology for Directed I/O (VT-d) and AMD I/O Virtualization (AMD-Vi or IOMMU), is enabled.
	// +kubebuilder:validation:Optional
	VvtdEnabled *bool `json:"vvtdEnabled,omitempty" tf:"vvtd_enabled,omitempty"`

	// The amount of time, in minutes, to wait for an available IP address on this virtual machine. A value less than 1 disables the waiter.
	// +kubebuilder:validation:Optional
	WaitForGuestIPTimeout *float64 `json:"waitForGuestIpTimeout,omitempty" tf:"wait_for_guest_ip_timeout,omitempty"`

	// Controls whether or not the guest network waiter waits for a routable address. When false, the waiter does not wait for a default gateway, nor are IP addresses checked against any discovered default gateways as part of its success criteria.
	// +kubebuilder:validation:Optional
	WaitForGuestNetRoutable *bool `json:"waitForGuestNetRoutable,omitempty" tf:"wait_for_guest_net_routable,omitempty"`

	// The amount of time, in minutes, to wait for an available IP address on this virtual machine. A value less than 1 disables the waiter.
	// +kubebuilder:validation:Optional
	WaitForGuestNetTimeout *float64 `json:"waitForGuestNetTimeout,omitempty" tf:"wait_for_guest_net_timeout,omitempty"`
}

type VappObservation struct {

	// A map of customizable vApp properties and their values. Allows customization of VMs cloned from OVF templates which have customizable vApp properties.
	Properties map[string]*string `json:"properties,omitempty" tf:"properties,omitempty"`
}

type VappParameters struct {

	// A map of customizable vApp properties and their values. Allows customization of VMs cloned from OVF templates which have customizable vApp properties.
	// +kubebuilder:validation:Optional
	Properties map[string]*string `json:"properties,omitempty" tf:"properties,omitempty"`
}

type WindowsOptionsObservation struct {

	// Specifies whether or not the VM automatically logs on as Administrator.
	AutoLogon *bool `json:"autoLogon,omitempty" tf:"auto_logon,omitempty"`

	// Specifies how many times the VM should auto-logon the Administrator account when auto_logon is true.
	AutoLogonCount *float64 `json:"autoLogonCount,omitempty" tf:"auto_logon_count,omitempty"`

	// The host name for this virtual machine.
	ComputerName *string `json:"computerName,omitempty" tf:"computer_name,omitempty"`

	// The user account of the domain administrator used to join this virtual machine to the domain.
	DomainAdminUser *string `json:"domainAdminUser,omitempty" tf:"domain_admin_user,omitempty"`

	// The full name of the user of this virtual machine.
	FullName *string `json:"fullName,omitempty" tf:"full_name,omitempty"`

	// The domain that the virtual machine should join.
	JoinDomain *string `json:"joinDomain,omitempty" tf:"join_domain,omitempty"`

	// The organization name this virtual machine is being installed for.
	OrganizationName *string `json:"organizationName,omitempty" tf:"organization_name,omitempty"`

	// A list of commands to run at first user logon, after guest customization.
	RunOnceCommandList []*string `json:"runOnceCommandList,omitempty" tf:"run_once_command_list,omitempty"`

	// The new time zone for the virtual machine. This is a sysprep-dictated timezone code.
	TimeZone *float64 `json:"timeZone,omitempty" tf:"time_zone,omitempty"`

	// The workgroup for this virtual machine if not joining a domain.
	Workgroup *string `json:"workgroup,omitempty" tf:"workgroup,omitempty"`
}

type WindowsOptionsParameters struct {

	// The new administrator password for this virtual machine.
	// +kubebuilder:validation:Optional
	AdminPasswordSecretRef *v1.SecretKeySelector `json:"adminPasswordSecretRef,omitempty" tf:"-"`

	// Specifies whether or not the VM automatically logs on as Administrator.
	// +kubebuilder:validation:Optional
	AutoLogon *bool `json:"autoLogon,omitempty" tf:"auto_logon,omitempty"`

	// Specifies how many times the VM should auto-logon the Administrator account when auto_logon is true.
	// +kubebuilder:validation:Optional
	AutoLogonCount *float64 `json:"autoLogonCount,omitempty" tf:"auto_logon_count,omitempty"`

	// The host name for this virtual machine.
	// +kubebuilder:validation:Required
	ComputerName *string `json:"computerName" tf:"computer_name,omitempty"`

	// The password of the domain administrator used to join this virtual machine to the domain.
	// +kubebuilder:validation:Optional
	DomainAdminPasswordSecretRef *v1.SecretKeySelector `json:"domainAdminPasswordSecretRef,omitempty" tf:"-"`

	// The user account of the domain administrator used to join this virtual machine to the domain.
	// +kubebuilder:validation:Optional
	DomainAdminUser *string `json:"domainAdminUser,omitempty" tf:"domain_admin_user,omitempty"`

	// The full name of the user of this virtual machine.
	// +kubebuilder:validation:Optional
	FullName *string `json:"fullName,omitempty" tf:"full_name,omitempty"`

	// The domain that the virtual machine should join.
	// +kubebuilder:validation:Optional
	JoinDomain *string `json:"joinDomain,omitempty" tf:"join_domain,omitempty"`

	// The organization name this virtual machine is being installed for.
	// +kubebuilder:validation:Optional
	OrganizationName *string `json:"organizationName,omitempty" tf:"organization_name,omitempty"`

	// The product key for this virtual machine.
	// +kubebuilder:validation:Optional
	ProductKeySecretRef *v1.SecretKeySelector `json:"productKeySecretRef,omitempty" tf:"-"`

	// A list of commands to run at first user logon, after guest customization.
	// +kubebuilder:validation:Optional
	RunOnceCommandList []*string `json:"runOnceCommandList,omitempty" tf:"run_once_command_list,omitempty"`

	// The new time zone for the virtual machine. This is a sysprep-dictated timezone code.
	// +kubebuilder:validation:Optional
	TimeZone *float64 `json:"timeZone,omitempty" tf:"time_zone,omitempty"`

	// The workgroup for this virtual machine if not joining a domain.
	// +kubebuilder:validation:Optional
	Workgroup *string `json:"workgroup,omitempty" tf:"workgroup,omitempty"`
}

// VSphereVirtualMachineSpec defines the desired state of VSphereVirtualMachine
type VSphereVirtualMachineSpec struct {
	v1.ResourceSpec `json:",inline"`
	ForProvider     VSphereVirtualMachineParameters `json:"forProvider"`
}

// VSphereVirtualMachineStatus defines the observed state of VSphereVirtualMachine.
type VSphereVirtualMachineStatus struct {
	v1.ResourceStatus `json:",inline"`
	AtProvider        VSphereVirtualMachineObservation `json:"atProvider,omitempty"`
}

// +kubebuilder:object:root=true

// VSphereVirtualMachine is the Schema for the VSphereVirtualMachines API. <no value>
// +kubebuilder:printcolumn:name="READY",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="SYNCED",type="string",JSONPath=".status.conditions[?(@.type=='Synced')].status"
// +kubebuilder:printcolumn:name="EXTERNAL-NAME",type="string",JSONPath=".metadata.annotations.crossplane\\.io/external-name"
// +kubebuilder:printcolumn:name="AGE",type="date",JSONPath=".metadata.creationTimestamp"
// +kubebuilder:subresource:status
// +kubebuilder:resource:scope=Cluster,categories={crossplane,managed,vsphere}
type VSphereVirtualMachine struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	// +kubebuilder:validation:XValidation:rule="self.managementPolicy == 'ObserveOnly' || has(self.forProvider.name)",message="name is a required parameter"
	// +kubebuilder:validation:XValidation:rule="self.managementPolicy == 'ObserveOnly' || has(self.forProvider.resourcePoolId)",message="resourcePoolId is a required parameter"
	Spec   VSphereVirtualMachineSpec   `json:"spec"`
	Status VSphereVirtualMachineStatus `json:"status,omitempty"`
}

// +kubebuilder:object:root=true

// VSphereVirtualMachineList contains a list of VSphereVirtualMachines
type VSphereVirtualMachineList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []VSphereVirtualMachine `json:"items"`
}

// Repository type metadata.
var (
	VSphereVirtualMachine_Kind             = "VSphereVirtualMachine"
	VSphereVirtualMachine_GroupKind        = schema.GroupKind{Group: CRDGroup, Kind: VSphereVirtualMachine_Kind}.String()
	VSphereVirtualMachine_KindAPIVersion   = VSphereVirtualMachine_Kind + "." + CRDGroupVersion.String()
	VSphereVirtualMachine_GroupVersionKind = CRDGroupVersion.WithKind(VSphereVirtualMachine_Kind)
)

func init() {
	SchemeBuilder.Register(&VSphereVirtualMachine{}, &VSphereVirtualMachineList{})
}
