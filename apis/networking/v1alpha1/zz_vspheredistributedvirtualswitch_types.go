/*
Copyright 2022 Upbound Inc.
*/

// Code generated by upjet. DO NOT EDIT.

package v1alpha1

import (
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime/schema"

	v1 "github.com/crossplane/crossplane-runtime/apis/common/v1"
)

type HostObservation struct {

	// Name of the physical NIC to be added to the proxy switch.
	Devices []*string `json:"devices,omitempty" tf:"devices,omitempty"`

	// The managed object ID of the host this specification applies to.
	HostSystemID *string `json:"hostSystemId,omitempty" tf:"host_system_id,omitempty"`
}

type HostParameters struct {

	// Name of the physical NIC to be added to the proxy switch.
	// +kubebuilder:validation:Optional
	Devices []*string `json:"devices,omitempty" tf:"devices,omitempty"`

	// The managed object ID of the host this specification applies to.
	// +kubebuilder:validation:Required
	HostSystemID *string `json:"hostSystemId" tf:"host_system_id,omitempty"`
}

type PvlanMappingObservation struct {

	// The primary VLAN ID. The VLAN IDs of 0 and 4095 are reserved and cannot be used in this property.
	PrimaryVlanID *float64 `json:"primaryVlanId,omitempty" tf:"primary_vlan_id,omitempty"`

	// The private VLAN type. Valid values are promiscuous, community and isolated.
	PvlanType *string `json:"pvlanType,omitempty" tf:"pvlan_type,omitempty"`

	// The secondary VLAN ID. The VLAN IDs of 0 and 4095 are reserved and cannot be used in this property.
	SecondaryVlanID *float64 `json:"secondaryVlanId,omitempty" tf:"secondary_vlan_id,omitempty"`
}

type PvlanMappingParameters struct {

	// The primary VLAN ID. The VLAN IDs of 0 and 4095 are reserved and cannot be used in this property.
	// +kubebuilder:validation:Required
	PrimaryVlanID *float64 `json:"primaryVlanId" tf:"primary_vlan_id,omitempty"`

	// The private VLAN type. Valid values are promiscuous, community and isolated.
	// +kubebuilder:validation:Required
	PvlanType *string `json:"pvlanType" tf:"pvlan_type,omitempty"`

	// The secondary VLAN ID. The VLAN IDs of 0 and 4095 are reserved and cannot be used in this property.
	// +kubebuilder:validation:Required
	SecondaryVlanID *float64 `json:"secondaryVlanId" tf:"secondary_vlan_id,omitempty"`
}

type VSphereDistributedVirtualSwitchObservation struct {

	// List of active uplinks used for load balancing, matching the names of the uplinks assigned in the DVS.
	ActiveUplinks []*string `json:"activeUplinks,omitempty" tf:"active_uplinks,omitempty"`

	// Controls whether or not the virtual network adapter is allowed to send network traffic with a different MAC address than that of its own.
	AllowForgedTransmits *bool `json:"allowForgedTransmits,omitempty" tf:"allow_forged_transmits,omitempty"`

	// Controls whether or not the Media Access Control (MAC) address can be changed.
	AllowMacChanges *bool `json:"allowMacChanges,omitempty" tf:"allow_mac_changes,omitempty"`

	// Enable promiscuous mode on the network. This flag indicates whether or not all traffic is seen on a given port.
	AllowPromiscuous *bool `json:"allowPromiscuous,omitempty" tf:"allow_promiscuous,omitempty"`

	// The maximum allowed usage for the backupNfc traffic class, in Mbits/sec.
	BackupnfcMaximumMbit *float64 `json:"backupnfcMaximumMbit,omitempty" tf:"backupnfc_maximum_mbit,omitempty"`

	// The amount of guaranteed bandwidth for the backupNfc traffic class, in Mbits/sec.
	BackupnfcReservationMbit *float64 `json:"backupnfcReservationMbit,omitempty" tf:"backupnfc_reservation_mbit,omitempty"`

	// The amount of shares to allocate to the backupNfc traffic class for a custom share level.
	BackupnfcShareCount *float64 `json:"backupnfcShareCount,omitempty" tf:"backupnfc_share_count,omitempty"`

	// The allocation level for the backupNfc traffic class. Can be one of high, low, normal, or custom.
	BackupnfcShareLevel *string `json:"backupnfcShareLevel,omitempty" tf:"backupnfc_share_level,omitempty"`

	// Indicates whether to block all ports by default.
	BlockAllPorts *bool `json:"blockAllPorts,omitempty" tf:"block_all_ports,omitempty"`

	// Enable beacon probing on the ports this policy applies to.
	CheckBeacon *bool `json:"checkBeacon,omitempty" tf:"check_beacon,omitempty"`

	// The version string of the configuration that this spec is trying to change.
	ConfigVersion *string `json:"configVersion,omitempty" tf:"config_version,omitempty"`

	// The contact detail for this DVS.
	ContactDetail *string `json:"contactDetail,omitempty" tf:"contact_detail,omitempty"`

	// The contact name for this DVS.
	ContactName *string `json:"contactName,omitempty" tf:"contact_name,omitempty"`

	// A list of custom attributes to set on this resource.
	CustomAttributes map[string]*string `json:"customAttributes,omitempty" tf:"custom_attributes,omitempty"`

	// The ID of the datacenter to create this virtual switch in.
	DatacenterID *string `json:"datacenterId,omitempty" tf:"datacenter_id,omitempty"`

	// The description of the DVS.
	Description *string `json:"description,omitempty" tf:"description,omitempty"`

	// Allow VMDirectPath Gen2 on the ports this policy applies to.
	DirectpathGen2Allowed *bool `json:"directpathGen2Allowed,omitempty" tf:"directpath_gen2_allowed,omitempty"`

	// The average egress bandwidth in bits per second if egress shaping is enabled on the port.
	EgressShapingAverageBandwidth *float64 `json:"egressShapingAverageBandwidth,omitempty" tf:"egress_shaping_average_bandwidth,omitempty"`

	// The maximum egress burst size allowed in bytes if egress shaping is enabled on the port.
	EgressShapingBurstSize *float64 `json:"egressShapingBurstSize,omitempty" tf:"egress_shaping_burst_size,omitempty"`

	// True if the traffic shaper is enabled for egress traffic on the port.
	EgressShapingEnabled *bool `json:"egressShapingEnabled,omitempty" tf:"egress_shaping_enabled,omitempty"`

	// The peak egress bandwidth during bursts in bits per second if egress traffic shaping is enabled on the port.
	EgressShapingPeakBandwidth *float64 `json:"egressShapingPeakBandwidth,omitempty" tf:"egress_shaping_peak_bandwidth,omitempty"`

	// If true, the teaming policy will re-activate failed interfaces higher in precedence when they come back up.
	Failback *bool `json:"failback,omitempty" tf:"failback,omitempty"`

	// The maximum allowed usage for the faultTolerance traffic class, in Mbits/sec.
	FaulttoleranceMaximumMbit *float64 `json:"faulttoleranceMaximumMbit,omitempty" tf:"faulttolerance_maximum_mbit,omitempty"`

	// The amount of guaranteed bandwidth for the faultTolerance traffic class, in Mbits/sec.
	FaulttoleranceReservationMbit *float64 `json:"faulttoleranceReservationMbit,omitempty" tf:"faulttolerance_reservation_mbit,omitempty"`

	// The amount of shares to allocate to the faultTolerance traffic class for a custom share level.
	FaulttoleranceShareCount *float64 `json:"faulttoleranceShareCount,omitempty" tf:"faulttolerance_share_count,omitempty"`

	// The allocation level for the faultTolerance traffic class. Can be one of high, low, normal, or custom.
	FaulttoleranceShareLevel *string `json:"faulttoleranceShareLevel,omitempty" tf:"faulttolerance_share_level,omitempty"`

	// The folder to create this virtual switch in, relative to the datacenter.
	Folder *string `json:"folder,omitempty" tf:"folder,omitempty"`

	// The maximum allowed usage for the hbr traffic class, in Mbits/sec.
	HbrMaximumMbit *float64 `json:"hbrMaximumMbit,omitempty" tf:"hbr_maximum_mbit,omitempty"`

	// The amount of guaranteed bandwidth for the hbr traffic class, in Mbits/sec.
	HbrReservationMbit *float64 `json:"hbrReservationMbit,omitempty" tf:"hbr_reservation_mbit,omitempty"`

	// The amount of shares to allocate to the hbr traffic class for a custom share level.
	HbrShareCount *float64 `json:"hbrShareCount,omitempty" tf:"hbr_share_count,omitempty"`

	// The allocation level for the hbr traffic class. Can be one of high, low, normal, or custom.
	HbrShareLevel *string `json:"hbrShareLevel,omitempty" tf:"hbr_share_level,omitempty"`

	// A host member specification.
	Host []HostObservation `json:"host,omitempty" tf:"host,omitempty"`

	ID *string `json:"id,omitempty" tf:"id,omitempty"`

	// The IPv4 address of the switch. This can be used to see the DVS as a unique device with NetFlow.
	IPv4Address *string `json:"ipv4Address,omitempty" tf:"ipv4_address,omitempty"`

	// The maximum allowed usage for the iSCSI traffic class, in Mbits/sec.
	ISCSIMaximumMbit *float64 `json:"iscsiMaximumMbit,omitempty" tf:"iscsi_maximum_mbit,omitempty"`

	// The amount of guaranteed bandwidth for the iSCSI traffic class, in Mbits/sec.
	ISCSIReservationMbit *float64 `json:"iscsiReservationMbit,omitempty" tf:"iscsi_reservation_mbit,omitempty"`

	// The amount of shares to allocate to the iSCSI traffic class for a custom share level.
	ISCSIShareCount *float64 `json:"iscsiShareCount,omitempty" tf:"iscsi_share_count,omitempty"`

	// The allocation level for the iSCSI traffic class. Can be one of high, low, normal, or custom.
	ISCSIShareLevel *string `json:"iscsiShareLevel,omitempty" tf:"iscsi_share_level,omitempty"`

	// Whether to ignore existing PVLAN mappings not managed by this resource. Defaults to false.
	IgnoreOtherPvlanMappings *bool `json:"ignoreOtherPvlanMappings,omitempty" tf:"ignore_other_pvlan_mappings,omitempty"`

	// The average ingress bandwidth in bits per second if ingress shaping is enabled on the port.
	IngressShapingAverageBandwidth *float64 `json:"ingressShapingAverageBandwidth,omitempty" tf:"ingress_shaping_average_bandwidth,omitempty"`

	// The maximum ingress burst size allowed in bytes if ingress shaping is enabled on the port.
	IngressShapingBurstSize *float64 `json:"ingressShapingBurstSize,omitempty" tf:"ingress_shaping_burst_size,omitempty"`

	// True if the traffic shaper is enabled for ingress traffic on the port.
	IngressShapingEnabled *bool `json:"ingressShapingEnabled,omitempty" tf:"ingress_shaping_enabled,omitempty"`

	// The peak ingress bandwidth during bursts in bits per second if ingress traffic shaping is enabled on the port.
	IngressShapingPeakBandwidth *float64 `json:"ingressShapingPeakBandwidth,omitempty" tf:"ingress_shaping_peak_bandwidth,omitempty"`

	// The Link Aggregation Control Protocol group version in the switch. Can be one of singleLag or multipleLag.
	LacpAPIVersion *string `json:"lacpApiVersion,omitempty" tf:"lacp_api_version,omitempty"`

	// Whether or not to enable LACP on all uplink ports.
	LacpEnabled *bool `json:"lacpEnabled,omitempty" tf:"lacp_enabled,omitempty"`

	// The uplink LACP mode to use. Can be one of active or passive.
	LacpMode *string `json:"lacpMode,omitempty" tf:"lacp_mode,omitempty"`

	// Whether to advertise or listen for link discovery. Valid values are advertise, both, listen, and none.
	LinkDiscoveryOperation *string `json:"linkDiscoveryOperation,omitempty" tf:"link_discovery_operation,omitempty"`

	// The discovery protocol type. Valid values are cdp and lldp.
	LinkDiscoveryProtocol *string `json:"linkDiscoveryProtocol,omitempty" tf:"link_discovery_protocol,omitempty"`

	// The maximum allowed usage for the management traffic class, in Mbits/sec.
	ManagementMaximumMbit *float64 `json:"managementMaximumMbit,omitempty" tf:"management_maximum_mbit,omitempty"`

	// The amount of guaranteed bandwidth for the management traffic class, in Mbits/sec.
	ManagementReservationMbit *float64 `json:"managementReservationMbit,omitempty" tf:"management_reservation_mbit,omitempty"`

	// The amount of shares to allocate to the management traffic class for a custom share level.
	ManagementShareCount *float64 `json:"managementShareCount,omitempty" tf:"management_share_count,omitempty"`

	// The allocation level for the management traffic class. Can be one of high, low, normal, or custom.
	ManagementShareLevel *string `json:"managementShareLevel,omitempty" tf:"management_share_level,omitempty"`

	// The maximum MTU on the switch.
	MaxMtu *float64 `json:"maxMtu,omitempty" tf:"max_mtu,omitempty"`

	// The multicast filtering mode on the switch. Can be one of legacyFiltering, or snooping.
	MulticastFilteringMode *string `json:"multicastFilteringMode,omitempty" tf:"multicast_filtering_mode,omitempty"`

	// The maximum allowed usage for the nfs traffic class, in Mbits/sec.
	NFSMaximumMbit *float64 `json:"nfsMaximumMbit,omitempty" tf:"nfs_maximum_mbit,omitempty"`

	// The amount of guaranteed bandwidth for the nfs traffic class, in Mbits/sec.
	NFSReservationMbit *float64 `json:"nfsReservationMbit,omitempty" tf:"nfs_reservation_mbit,omitempty"`

	// The amount of shares to allocate to the nfs traffic class for a custom share level.
	NFSShareCount *float64 `json:"nfsShareCount,omitempty" tf:"nfs_share_count,omitempty"`

	// The allocation level for the nfs traffic class. Can be one of high, low, normal, or custom.
	NFSShareLevel *string `json:"nfsShareLevel,omitempty" tf:"nfs_share_level,omitempty"`

	// The name for the DVS. Must be unique in the folder that it is being created in.
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// The number of seconds after which active flows are forced to be exported to the collector.
	NetflowActiveFlowTimeout *float64 `json:"netflowActiveFlowTimeout,omitempty" tf:"netflow_active_flow_timeout,omitempty"`

	// IP address for the netflow collector, using IPv4 or IPv6. IPv6 is supported in vSphere Distributed Switch Version 6.0 or later.
	NetflowCollectorIPAddress *string `json:"netflowCollectorIpAddress,omitempty" tf:"netflow_collector_ip_address,omitempty"`

	// The port for the netflow collector.
	NetflowCollectorPort *float64 `json:"netflowCollectorPort,omitempty" tf:"netflow_collector_port,omitempty"`

	// Indicates whether to enable netflow on all ports.
	NetflowEnabled *bool `json:"netflowEnabled,omitempty" tf:"netflow_enabled,omitempty"`

	// The number of seconds after which idle flows are forced to be exported to the collector.
	NetflowIdleFlowTimeout *float64 `json:"netflowIdleFlowTimeout,omitempty" tf:"netflow_idle_flow_timeout,omitempty"`

	// Whether to limit analysis to traffic that has both source and destination served by the same host.
	NetflowInternalFlowsOnly *bool `json:"netflowInternalFlowsOnly,omitempty" tf:"netflow_internal_flows_only,omitempty"`

	// The observation Domain ID for the netflow collector.
	NetflowObservationDomainID *float64 `json:"netflowObservationDomainId,omitempty" tf:"netflow_observation_domain_id,omitempty"`

	// The ratio of total number of packets to the number of packets analyzed. Set to 0 to disable sampling, meaning that all packets are analyzed.
	NetflowSamplingRate *float64 `json:"netflowSamplingRate,omitempty" tf:"netflow_sampling_rate,omitempty"`

	// Whether or not to enable network resource control, enabling advanced traffic shaping and resource control features.
	NetworkResourceControlEnabled *bool `json:"networkResourceControlEnabled,omitempty" tf:"network_resource_control_enabled,omitempty"`

	// The network I/O control version to use. Can be one of version2 or version3.
	NetworkResourceControlVersion *string `json:"networkResourceControlVersion,omitempty" tf:"network_resource_control_version,omitempty"`

	// If true, the teaming policy will notify the broadcast network of a NIC failover, triggering cache updates.
	NotifySwitches *bool `json:"notifySwitches,omitempty" tf:"notify_switches,omitempty"`

	// The secondary VLAN ID for this port.
	PortPrivateSecondaryVlanID *float64 `json:"portPrivateSecondaryVlanId,omitempty" tf:"port_private_secondary_vlan_id,omitempty"`

	// A private VLAN (PVLAN) mapping.
	PvlanMapping []PvlanMappingObservation `json:"pvlanMapping,omitempty" tf:"pvlan_mapping,omitempty"`

	// List of standby uplinks used for load balancing, matching the names of the uplinks assigned in the DVS.
	StandbyUplinks []*string `json:"standbyUplinks,omitempty" tf:"standby_uplinks,omitempty"`

	// A list of tag IDs to apply to this object.
	Tags []*string `json:"tags,omitempty" tf:"tags,omitempty"`

	// The network adapter teaming policy. Can be one of loadbalance_ip, loadbalance_srcmac, loadbalance_srcid, failover_explicit, or loadbalance_loadbased.
	TeamingPolicy *string `json:"teamingPolicy,omitempty" tf:"teaming_policy,omitempty"`

	// If true, a copy of packets sent to the switch will always be forwarded to an uplink in addition to the regular packet forwarded done by the switch.
	TxUplink *bool `json:"txUplink,omitempty" tf:"tx_uplink,omitempty"`

	// A list of uplink ports. The contents of this list control both the uplink count and names of the uplinks on the DVS across hosts.
	Uplinks []*string `json:"uplinks,omitempty" tf:"uplinks,omitempty"`

	// The maximum allowed usage for the vdp traffic class, in Mbits/sec.
	VdpMaximumMbit *float64 `json:"vdpMaximumMbit,omitempty" tf:"vdp_maximum_mbit,omitempty"`

	// The amount of guaranteed bandwidth for the vdp traffic class, in Mbits/sec.
	VdpReservationMbit *float64 `json:"vdpReservationMbit,omitempty" tf:"vdp_reservation_mbit,omitempty"`

	// The amount of shares to allocate to the vdp traffic class for a custom share level.
	VdpShareCount *float64 `json:"vdpShareCount,omitempty" tf:"vdp_share_count,omitempty"`

	// The allocation level for the vdp traffic class. Can be one of high, low, normal, or custom.
	VdpShareLevel *string `json:"vdpShareLevel,omitempty" tf:"vdp_share_level,omitempty"`

	// The version of this virtual switch. Allowed versions are 8.0.0, 7.0.3, 7.0.2, 7.0.0, 6.6.0, 6.5.0, 6.0.0, 5.5.0, 5.1.0, and 5.0.0.
	Version *string `json:"version,omitempty" tf:"version,omitempty"`

	// The maximum allowed usage for the virtualMachine traffic class, in Mbits/sec.
	VirtualmachineMaximumMbit *float64 `json:"virtualmachineMaximumMbit,omitempty" tf:"virtualmachine_maximum_mbit,omitempty"`

	// The amount of guaranteed bandwidth for the virtualMachine traffic class, in Mbits/sec.
	VirtualmachineReservationMbit *float64 `json:"virtualmachineReservationMbit,omitempty" tf:"virtualmachine_reservation_mbit,omitempty"`

	// The amount of shares to allocate to the virtualMachine traffic class for a custom share level.
	VirtualmachineShareCount *float64 `json:"virtualmachineShareCount,omitempty" tf:"virtualmachine_share_count,omitempty"`

	// The allocation level for the virtualMachine traffic class. Can be one of high, low, normal, or custom.
	VirtualmachineShareLevel *string `json:"virtualmachineShareLevel,omitempty" tf:"virtualmachine_share_level,omitempty"`

	// The VLAN ID for single VLAN mode. 0 denotes no VLAN.
	VlanID *float64 `json:"vlanId,omitempty" tf:"vlan_id,omitempty"`

	// The VLAN ID for single VLAN mode. 0 denotes no VLAN.
	VlanRange []VSphereDistributedVirtualSwitchVlanRangeObservation `json:"vlanRange,omitempty" tf:"vlan_range,omitempty"`

	// The maximum allowed usage for the vmotion traffic class, in Mbits/sec.
	VmotionMaximumMbit *float64 `json:"vmotionMaximumMbit,omitempty" tf:"vmotion_maximum_mbit,omitempty"`

	// The amount of guaranteed bandwidth for the vmotion traffic class, in Mbits/sec.
	VmotionReservationMbit *float64 `json:"vmotionReservationMbit,omitempty" tf:"vmotion_reservation_mbit,omitempty"`

	// The amount of shares to allocate to the vmotion traffic class for a custom share level.
	VmotionShareCount *float64 `json:"vmotionShareCount,omitempty" tf:"vmotion_share_count,omitempty"`

	// The allocation level for the vmotion traffic class. Can be one of high, low, normal, or custom.
	VmotionShareLevel *string `json:"vmotionShareLevel,omitempty" tf:"vmotion_share_level,omitempty"`

	// The maximum allowed usage for the vsan traffic class, in Mbits/sec.
	VsanMaximumMbit *float64 `json:"vsanMaximumMbit,omitempty" tf:"vsan_maximum_mbit,omitempty"`

	// The amount of guaranteed bandwidth for the vsan traffic class, in Mbits/sec.
	VsanReservationMbit *float64 `json:"vsanReservationMbit,omitempty" tf:"vsan_reservation_mbit,omitempty"`

	// The amount of shares to allocate to the vsan traffic class for a custom share level.
	VsanShareCount *float64 `json:"vsanShareCount,omitempty" tf:"vsan_share_count,omitempty"`

	// The allocation level for the vsan traffic class. Can be one of high, low, normal, or custom.
	VsanShareLevel *string `json:"vsanShareLevel,omitempty" tf:"vsan_share_level,omitempty"`
}

type VSphereDistributedVirtualSwitchParameters struct {

	// List of active uplinks used for load balancing, matching the names of the uplinks assigned in the DVS.
	// +kubebuilder:validation:Optional
	ActiveUplinks []*string `json:"activeUplinks,omitempty" tf:"active_uplinks,omitempty"`

	// Controls whether or not the virtual network adapter is allowed to send network traffic with a different MAC address than that of its own.
	// +kubebuilder:validation:Optional
	AllowForgedTransmits *bool `json:"allowForgedTransmits,omitempty" tf:"allow_forged_transmits,omitempty"`

	// Controls whether or not the Media Access Control (MAC) address can be changed.
	// +kubebuilder:validation:Optional
	AllowMacChanges *bool `json:"allowMacChanges,omitempty" tf:"allow_mac_changes,omitempty"`

	// Enable promiscuous mode on the network. This flag indicates whether or not all traffic is seen on a given port.
	// +kubebuilder:validation:Optional
	AllowPromiscuous *bool `json:"allowPromiscuous,omitempty" tf:"allow_promiscuous,omitempty"`

	// The maximum allowed usage for the backupNfc traffic class, in Mbits/sec.
	// +kubebuilder:validation:Optional
	BackupnfcMaximumMbit *float64 `json:"backupnfcMaximumMbit,omitempty" tf:"backupnfc_maximum_mbit,omitempty"`

	// The amount of guaranteed bandwidth for the backupNfc traffic class, in Mbits/sec.
	// +kubebuilder:validation:Optional
	BackupnfcReservationMbit *float64 `json:"backupnfcReservationMbit,omitempty" tf:"backupnfc_reservation_mbit,omitempty"`

	// The amount of shares to allocate to the backupNfc traffic class for a custom share level.
	// +kubebuilder:validation:Optional
	BackupnfcShareCount *float64 `json:"backupnfcShareCount,omitempty" tf:"backupnfc_share_count,omitempty"`

	// The allocation level for the backupNfc traffic class. Can be one of high, low, normal, or custom.
	// +kubebuilder:validation:Optional
	BackupnfcShareLevel *string `json:"backupnfcShareLevel,omitempty" tf:"backupnfc_share_level,omitempty"`

	// Indicates whether to block all ports by default.
	// +kubebuilder:validation:Optional
	BlockAllPorts *bool `json:"blockAllPorts,omitempty" tf:"block_all_ports,omitempty"`

	// Enable beacon probing on the ports this policy applies to.
	// +kubebuilder:validation:Optional
	CheckBeacon *bool `json:"checkBeacon,omitempty" tf:"check_beacon,omitempty"`

	// The contact detail for this DVS.
	// +kubebuilder:validation:Optional
	ContactDetail *string `json:"contactDetail,omitempty" tf:"contact_detail,omitempty"`

	// The contact name for this DVS.
	// +kubebuilder:validation:Optional
	ContactName *string `json:"contactName,omitempty" tf:"contact_name,omitempty"`

	// A list of custom attributes to set on this resource.
	// +kubebuilder:validation:Optional
	CustomAttributes map[string]*string `json:"customAttributes,omitempty" tf:"custom_attributes,omitempty"`

	// The ID of the datacenter to create this virtual switch in.
	// +kubebuilder:validation:Optional
	DatacenterID *string `json:"datacenterId,omitempty" tf:"datacenter_id,omitempty"`

	// The description of the DVS.
	// +kubebuilder:validation:Optional
	Description *string `json:"description,omitempty" tf:"description,omitempty"`

	// Allow VMDirectPath Gen2 on the ports this policy applies to.
	// +kubebuilder:validation:Optional
	DirectpathGen2Allowed *bool `json:"directpathGen2Allowed,omitempty" tf:"directpath_gen2_allowed,omitempty"`

	// The average egress bandwidth in bits per second if egress shaping is enabled on the port.
	// +kubebuilder:validation:Optional
	EgressShapingAverageBandwidth *float64 `json:"egressShapingAverageBandwidth,omitempty" tf:"egress_shaping_average_bandwidth,omitempty"`

	// The maximum egress burst size allowed in bytes if egress shaping is enabled on the port.
	// +kubebuilder:validation:Optional
	EgressShapingBurstSize *float64 `json:"egressShapingBurstSize,omitempty" tf:"egress_shaping_burst_size,omitempty"`

	// True if the traffic shaper is enabled for egress traffic on the port.
	// +kubebuilder:validation:Optional
	EgressShapingEnabled *bool `json:"egressShapingEnabled,omitempty" tf:"egress_shaping_enabled,omitempty"`

	// The peak egress bandwidth during bursts in bits per second if egress traffic shaping is enabled on the port.
	// +kubebuilder:validation:Optional
	EgressShapingPeakBandwidth *float64 `json:"egressShapingPeakBandwidth,omitempty" tf:"egress_shaping_peak_bandwidth,omitempty"`

	// If true, the teaming policy will re-activate failed interfaces higher in precedence when they come back up.
	// +kubebuilder:validation:Optional
	Failback *bool `json:"failback,omitempty" tf:"failback,omitempty"`

	// The maximum allowed usage for the faultTolerance traffic class, in Mbits/sec.
	// +kubebuilder:validation:Optional
	FaulttoleranceMaximumMbit *float64 `json:"faulttoleranceMaximumMbit,omitempty" tf:"faulttolerance_maximum_mbit,omitempty"`

	// The amount of guaranteed bandwidth for the faultTolerance traffic class, in Mbits/sec.
	// +kubebuilder:validation:Optional
	FaulttoleranceReservationMbit *float64 `json:"faulttoleranceReservationMbit,omitempty" tf:"faulttolerance_reservation_mbit,omitempty"`

	// The amount of shares to allocate to the faultTolerance traffic class for a custom share level.
	// +kubebuilder:validation:Optional
	FaulttoleranceShareCount *float64 `json:"faulttoleranceShareCount,omitempty" tf:"faulttolerance_share_count,omitempty"`

	// The allocation level for the faultTolerance traffic class. Can be one of high, low, normal, or custom.
	// +kubebuilder:validation:Optional
	FaulttoleranceShareLevel *string `json:"faulttoleranceShareLevel,omitempty" tf:"faulttolerance_share_level,omitempty"`

	// The folder to create this virtual switch in, relative to the datacenter.
	// +kubebuilder:validation:Optional
	Folder *string `json:"folder,omitempty" tf:"folder,omitempty"`

	// The maximum allowed usage for the hbr traffic class, in Mbits/sec.
	// +kubebuilder:validation:Optional
	HbrMaximumMbit *float64 `json:"hbrMaximumMbit,omitempty" tf:"hbr_maximum_mbit,omitempty"`

	// The amount of guaranteed bandwidth for the hbr traffic class, in Mbits/sec.
	// +kubebuilder:validation:Optional
	HbrReservationMbit *float64 `json:"hbrReservationMbit,omitempty" tf:"hbr_reservation_mbit,omitempty"`

	// The amount of shares to allocate to the hbr traffic class for a custom share level.
	// +kubebuilder:validation:Optional
	HbrShareCount *float64 `json:"hbrShareCount,omitempty" tf:"hbr_share_count,omitempty"`

	// The allocation level for the hbr traffic class. Can be one of high, low, normal, or custom.
	// +kubebuilder:validation:Optional
	HbrShareLevel *string `json:"hbrShareLevel,omitempty" tf:"hbr_share_level,omitempty"`

	// A host member specification.
	// +kubebuilder:validation:Optional
	Host []HostParameters `json:"host,omitempty" tf:"host,omitempty"`

	// The IPv4 address of the switch. This can be used to see the DVS as a unique device with NetFlow.
	// +kubebuilder:validation:Optional
	IPv4Address *string `json:"ipv4Address,omitempty" tf:"ipv4_address,omitempty"`

	// The maximum allowed usage for the iSCSI traffic class, in Mbits/sec.
	// +kubebuilder:validation:Optional
	ISCSIMaximumMbit *float64 `json:"iscsiMaximumMbit,omitempty" tf:"iscsi_maximum_mbit,omitempty"`

	// The amount of guaranteed bandwidth for the iSCSI traffic class, in Mbits/sec.
	// +kubebuilder:validation:Optional
	ISCSIReservationMbit *float64 `json:"iscsiReservationMbit,omitempty" tf:"iscsi_reservation_mbit,omitempty"`

	// The amount of shares to allocate to the iSCSI traffic class for a custom share level.
	// +kubebuilder:validation:Optional
	ISCSIShareCount *float64 `json:"iscsiShareCount,omitempty" tf:"iscsi_share_count,omitempty"`

	// The allocation level for the iSCSI traffic class. Can be one of high, low, normal, or custom.
	// +kubebuilder:validation:Optional
	ISCSIShareLevel *string `json:"iscsiShareLevel,omitempty" tf:"iscsi_share_level,omitempty"`

	// Whether to ignore existing PVLAN mappings not managed by this resource. Defaults to false.
	// +kubebuilder:validation:Optional
	IgnoreOtherPvlanMappings *bool `json:"ignoreOtherPvlanMappings,omitempty" tf:"ignore_other_pvlan_mappings,omitempty"`

	// The average ingress bandwidth in bits per second if ingress shaping is enabled on the port.
	// +kubebuilder:validation:Optional
	IngressShapingAverageBandwidth *float64 `json:"ingressShapingAverageBandwidth,omitempty" tf:"ingress_shaping_average_bandwidth,omitempty"`

	// The maximum ingress burst size allowed in bytes if ingress shaping is enabled on the port.
	// +kubebuilder:validation:Optional
	IngressShapingBurstSize *float64 `json:"ingressShapingBurstSize,omitempty" tf:"ingress_shaping_burst_size,omitempty"`

	// True if the traffic shaper is enabled for ingress traffic on the port.
	// +kubebuilder:validation:Optional
	IngressShapingEnabled *bool `json:"ingressShapingEnabled,omitempty" tf:"ingress_shaping_enabled,omitempty"`

	// The peak ingress bandwidth during bursts in bits per second if ingress traffic shaping is enabled on the port.
	// +kubebuilder:validation:Optional
	IngressShapingPeakBandwidth *float64 `json:"ingressShapingPeakBandwidth,omitempty" tf:"ingress_shaping_peak_bandwidth,omitempty"`

	// The Link Aggregation Control Protocol group version in the switch. Can be one of singleLag or multipleLag.
	// +kubebuilder:validation:Optional
	LacpAPIVersion *string `json:"lacpApiVersion,omitempty" tf:"lacp_api_version,omitempty"`

	// Whether or not to enable LACP on all uplink ports.
	// +kubebuilder:validation:Optional
	LacpEnabled *bool `json:"lacpEnabled,omitempty" tf:"lacp_enabled,omitempty"`

	// The uplink LACP mode to use. Can be one of active or passive.
	// +kubebuilder:validation:Optional
	LacpMode *string `json:"lacpMode,omitempty" tf:"lacp_mode,omitempty"`

	// Whether to advertise or listen for link discovery. Valid values are advertise, both, listen, and none.
	// +kubebuilder:validation:Optional
	LinkDiscoveryOperation *string `json:"linkDiscoveryOperation,omitempty" tf:"link_discovery_operation,omitempty"`

	// The discovery protocol type. Valid values are cdp and lldp.
	// +kubebuilder:validation:Optional
	LinkDiscoveryProtocol *string `json:"linkDiscoveryProtocol,omitempty" tf:"link_discovery_protocol,omitempty"`

	// The maximum allowed usage for the management traffic class, in Mbits/sec.
	// +kubebuilder:validation:Optional
	ManagementMaximumMbit *float64 `json:"managementMaximumMbit,omitempty" tf:"management_maximum_mbit,omitempty"`

	// The amount of guaranteed bandwidth for the management traffic class, in Mbits/sec.
	// +kubebuilder:validation:Optional
	ManagementReservationMbit *float64 `json:"managementReservationMbit,omitempty" tf:"management_reservation_mbit,omitempty"`

	// The amount of shares to allocate to the management traffic class for a custom share level.
	// +kubebuilder:validation:Optional
	ManagementShareCount *float64 `json:"managementShareCount,omitempty" tf:"management_share_count,omitempty"`

	// The allocation level for the management traffic class. Can be one of high, low, normal, or custom.
	// +kubebuilder:validation:Optional
	ManagementShareLevel *string `json:"managementShareLevel,omitempty" tf:"management_share_level,omitempty"`

	// The maximum MTU on the switch.
	// +kubebuilder:validation:Optional
	MaxMtu *float64 `json:"maxMtu,omitempty" tf:"max_mtu,omitempty"`

	// The multicast filtering mode on the switch. Can be one of legacyFiltering, or snooping.
	// +kubebuilder:validation:Optional
	MulticastFilteringMode *string `json:"multicastFilteringMode,omitempty" tf:"multicast_filtering_mode,omitempty"`

	// The maximum allowed usage for the nfs traffic class, in Mbits/sec.
	// +kubebuilder:validation:Optional
	NFSMaximumMbit *float64 `json:"nfsMaximumMbit,omitempty" tf:"nfs_maximum_mbit,omitempty"`

	// The amount of guaranteed bandwidth for the nfs traffic class, in Mbits/sec.
	// +kubebuilder:validation:Optional
	NFSReservationMbit *float64 `json:"nfsReservationMbit,omitempty" tf:"nfs_reservation_mbit,omitempty"`

	// The amount of shares to allocate to the nfs traffic class for a custom share level.
	// +kubebuilder:validation:Optional
	NFSShareCount *float64 `json:"nfsShareCount,omitempty" tf:"nfs_share_count,omitempty"`

	// The allocation level for the nfs traffic class. Can be one of high, low, normal, or custom.
	// +kubebuilder:validation:Optional
	NFSShareLevel *string `json:"nfsShareLevel,omitempty" tf:"nfs_share_level,omitempty"`

	// The name for the DVS. Must be unique in the folder that it is being created in.
	// +kubebuilder:validation:Optional
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// The number of seconds after which active flows are forced to be exported to the collector.
	// +kubebuilder:validation:Optional
	NetflowActiveFlowTimeout *float64 `json:"netflowActiveFlowTimeout,omitempty" tf:"netflow_active_flow_timeout,omitempty"`

	// IP address for the netflow collector, using IPv4 or IPv6. IPv6 is supported in vSphere Distributed Switch Version 6.0 or later.
	// +kubebuilder:validation:Optional
	NetflowCollectorIPAddress *string `json:"netflowCollectorIpAddress,omitempty" tf:"netflow_collector_ip_address,omitempty"`

	// The port for the netflow collector.
	// +kubebuilder:validation:Optional
	NetflowCollectorPort *float64 `json:"netflowCollectorPort,omitempty" tf:"netflow_collector_port,omitempty"`

	// Indicates whether to enable netflow on all ports.
	// +kubebuilder:validation:Optional
	NetflowEnabled *bool `json:"netflowEnabled,omitempty" tf:"netflow_enabled,omitempty"`

	// The number of seconds after which idle flows are forced to be exported to the collector.
	// +kubebuilder:validation:Optional
	NetflowIdleFlowTimeout *float64 `json:"netflowIdleFlowTimeout,omitempty" tf:"netflow_idle_flow_timeout,omitempty"`

	// Whether to limit analysis to traffic that has both source and destination served by the same host.
	// +kubebuilder:validation:Optional
	NetflowInternalFlowsOnly *bool `json:"netflowInternalFlowsOnly,omitempty" tf:"netflow_internal_flows_only,omitempty"`

	// The observation Domain ID for the netflow collector.
	// +kubebuilder:validation:Optional
	NetflowObservationDomainID *float64 `json:"netflowObservationDomainId,omitempty" tf:"netflow_observation_domain_id,omitempty"`

	// The ratio of total number of packets to the number of packets analyzed. Set to 0 to disable sampling, meaning that all packets are analyzed.
	// +kubebuilder:validation:Optional
	NetflowSamplingRate *float64 `json:"netflowSamplingRate,omitempty" tf:"netflow_sampling_rate,omitempty"`

	// Whether or not to enable network resource control, enabling advanced traffic shaping and resource control features.
	// +kubebuilder:validation:Optional
	NetworkResourceControlEnabled *bool `json:"networkResourceControlEnabled,omitempty" tf:"network_resource_control_enabled,omitempty"`

	// The network I/O control version to use. Can be one of version2 or version3.
	// +kubebuilder:validation:Optional
	NetworkResourceControlVersion *string `json:"networkResourceControlVersion,omitempty" tf:"network_resource_control_version,omitempty"`

	// If true, the teaming policy will notify the broadcast network of a NIC failover, triggering cache updates.
	// +kubebuilder:validation:Optional
	NotifySwitches *bool `json:"notifySwitches,omitempty" tf:"notify_switches,omitempty"`

	// The secondary VLAN ID for this port.
	// +kubebuilder:validation:Optional
	PortPrivateSecondaryVlanID *float64 `json:"portPrivateSecondaryVlanId,omitempty" tf:"port_private_secondary_vlan_id,omitempty"`

	// A private VLAN (PVLAN) mapping.
	// +kubebuilder:validation:Optional
	PvlanMapping []PvlanMappingParameters `json:"pvlanMapping,omitempty" tf:"pvlan_mapping,omitempty"`

	// List of standby uplinks used for load balancing, matching the names of the uplinks assigned in the DVS.
	// +kubebuilder:validation:Optional
	StandbyUplinks []*string `json:"standbyUplinks,omitempty" tf:"standby_uplinks,omitempty"`

	// A list of tag IDs to apply to this object.
	// +kubebuilder:validation:Optional
	Tags []*string `json:"tags,omitempty" tf:"tags,omitempty"`

	// The network adapter teaming policy. Can be one of loadbalance_ip, loadbalance_srcmac, loadbalance_srcid, failover_explicit, or loadbalance_loadbased.
	// +kubebuilder:validation:Optional
	TeamingPolicy *string `json:"teamingPolicy,omitempty" tf:"teaming_policy,omitempty"`

	// If true, a copy of packets sent to the switch will always be forwarded to an uplink in addition to the regular packet forwarded done by the switch.
	// +kubebuilder:validation:Optional
	TxUplink *bool `json:"txUplink,omitempty" tf:"tx_uplink,omitempty"`

	// A list of uplink ports. The contents of this list control both the uplink count and names of the uplinks on the DVS across hosts.
	// +kubebuilder:validation:Optional
	Uplinks []*string `json:"uplinks,omitempty" tf:"uplinks,omitempty"`

	// The maximum allowed usage for the vdp traffic class, in Mbits/sec.
	// +kubebuilder:validation:Optional
	VdpMaximumMbit *float64 `json:"vdpMaximumMbit,omitempty" tf:"vdp_maximum_mbit,omitempty"`

	// The amount of guaranteed bandwidth for the vdp traffic class, in Mbits/sec.
	// +kubebuilder:validation:Optional
	VdpReservationMbit *float64 `json:"vdpReservationMbit,omitempty" tf:"vdp_reservation_mbit,omitempty"`

	// The amount of shares to allocate to the vdp traffic class for a custom share level.
	// +kubebuilder:validation:Optional
	VdpShareCount *float64 `json:"vdpShareCount,omitempty" tf:"vdp_share_count,omitempty"`

	// The allocation level for the vdp traffic class. Can be one of high, low, normal, or custom.
	// +kubebuilder:validation:Optional
	VdpShareLevel *string `json:"vdpShareLevel,omitempty" tf:"vdp_share_level,omitempty"`

	// The version of this virtual switch. Allowed versions are 8.0.0, 7.0.3, 7.0.2, 7.0.0, 6.6.0, 6.5.0, 6.0.0, 5.5.0, 5.1.0, and 5.0.0.
	// +kubebuilder:validation:Optional
	Version *string `json:"version,omitempty" tf:"version,omitempty"`

	// The maximum allowed usage for the virtualMachine traffic class, in Mbits/sec.
	// +kubebuilder:validation:Optional
	VirtualmachineMaximumMbit *float64 `json:"virtualmachineMaximumMbit,omitempty" tf:"virtualmachine_maximum_mbit,omitempty"`

	// The amount of guaranteed bandwidth for the virtualMachine traffic class, in Mbits/sec.
	// +kubebuilder:validation:Optional
	VirtualmachineReservationMbit *float64 `json:"virtualmachineReservationMbit,omitempty" tf:"virtualmachine_reservation_mbit,omitempty"`

	// The amount of shares to allocate to the virtualMachine traffic class for a custom share level.
	// +kubebuilder:validation:Optional
	VirtualmachineShareCount *float64 `json:"virtualmachineShareCount,omitempty" tf:"virtualmachine_share_count,omitempty"`

	// The allocation level for the virtualMachine traffic class. Can be one of high, low, normal, or custom.
	// +kubebuilder:validation:Optional
	VirtualmachineShareLevel *string `json:"virtualmachineShareLevel,omitempty" tf:"virtualmachine_share_level,omitempty"`

	// The VLAN ID for single VLAN mode. 0 denotes no VLAN.
	// +kubebuilder:validation:Optional
	VlanID *float64 `json:"vlanId,omitempty" tf:"vlan_id,omitempty"`

	// The VLAN ID for single VLAN mode. 0 denotes no VLAN.
	// +kubebuilder:validation:Optional
	VlanRange []VSphereDistributedVirtualSwitchVlanRangeParameters `json:"vlanRange,omitempty" tf:"vlan_range,omitempty"`

	// The maximum allowed usage for the vmotion traffic class, in Mbits/sec.
	// +kubebuilder:validation:Optional
	VmotionMaximumMbit *float64 `json:"vmotionMaximumMbit,omitempty" tf:"vmotion_maximum_mbit,omitempty"`

	// The amount of guaranteed bandwidth for the vmotion traffic class, in Mbits/sec.
	// +kubebuilder:validation:Optional
	VmotionReservationMbit *float64 `json:"vmotionReservationMbit,omitempty" tf:"vmotion_reservation_mbit,omitempty"`

	// The amount of shares to allocate to the vmotion traffic class for a custom share level.
	// +kubebuilder:validation:Optional
	VmotionShareCount *float64 `json:"vmotionShareCount,omitempty" tf:"vmotion_share_count,omitempty"`

	// The allocation level for the vmotion traffic class. Can be one of high, low, normal, or custom.
	// +kubebuilder:validation:Optional
	VmotionShareLevel *string `json:"vmotionShareLevel,omitempty" tf:"vmotion_share_level,omitempty"`

	// The maximum allowed usage for the vsan traffic class, in Mbits/sec.
	// +kubebuilder:validation:Optional
	VsanMaximumMbit *float64 `json:"vsanMaximumMbit,omitempty" tf:"vsan_maximum_mbit,omitempty"`

	// The amount of guaranteed bandwidth for the vsan traffic class, in Mbits/sec.
	// +kubebuilder:validation:Optional
	VsanReservationMbit *float64 `json:"vsanReservationMbit,omitempty" tf:"vsan_reservation_mbit,omitempty"`

	// The amount of shares to allocate to the vsan traffic class for a custom share level.
	// +kubebuilder:validation:Optional
	VsanShareCount *float64 `json:"vsanShareCount,omitempty" tf:"vsan_share_count,omitempty"`

	// The allocation level for the vsan traffic class. Can be one of high, low, normal, or custom.
	// +kubebuilder:validation:Optional
	VsanShareLevel *string `json:"vsanShareLevel,omitempty" tf:"vsan_share_level,omitempty"`
}

type VSphereDistributedVirtualSwitchVlanRangeObservation struct {

	// The minimum VLAN to use in the range.
	MaxVlan *float64 `json:"maxVlan,omitempty" tf:"max_vlan,omitempty"`

	// The minimum VLAN to use in the range.
	MinVlan *float64 `json:"minVlan,omitempty" tf:"min_vlan,omitempty"`
}

type VSphereDistributedVirtualSwitchVlanRangeParameters struct {

	// The minimum VLAN to use in the range.
	// +kubebuilder:validation:Required
	MaxVlan *float64 `json:"maxVlan" tf:"max_vlan,omitempty"`

	// The minimum VLAN to use in the range.
	// +kubebuilder:validation:Required
	MinVlan *float64 `json:"minVlan" tf:"min_vlan,omitempty"`
}

// VSphereDistributedVirtualSwitchSpec defines the desired state of VSphereDistributedVirtualSwitch
type VSphereDistributedVirtualSwitchSpec struct {
	v1.ResourceSpec `json:",inline"`
	ForProvider     VSphereDistributedVirtualSwitchParameters `json:"forProvider"`
}

// VSphereDistributedVirtualSwitchStatus defines the observed state of VSphereDistributedVirtualSwitch.
type VSphereDistributedVirtualSwitchStatus struct {
	v1.ResourceStatus `json:",inline"`
	AtProvider        VSphereDistributedVirtualSwitchObservation `json:"atProvider,omitempty"`
}

// +kubebuilder:object:root=true

// VSphereDistributedVirtualSwitch is the Schema for the VSphereDistributedVirtualSwitchs API. <no value>
// +kubebuilder:printcolumn:name="READY",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="SYNCED",type="string",JSONPath=".status.conditions[?(@.type=='Synced')].status"
// +kubebuilder:printcolumn:name="EXTERNAL-NAME",type="string",JSONPath=".metadata.annotations.crossplane\\.io/external-name"
// +kubebuilder:printcolumn:name="AGE",type="date",JSONPath=".metadata.creationTimestamp"
// +kubebuilder:subresource:status
// +kubebuilder:resource:scope=Cluster,categories={crossplane,managed,vsphere}
type VSphereDistributedVirtualSwitch struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	// +kubebuilder:validation:XValidation:rule="self.managementPolicy == 'ObserveOnly' || has(self.forProvider.datacenterId)",message="datacenterId is a required parameter"
	// +kubebuilder:validation:XValidation:rule="self.managementPolicy == 'ObserveOnly' || has(self.forProvider.name)",message="name is a required parameter"
	Spec   VSphereDistributedVirtualSwitchSpec   `json:"spec"`
	Status VSphereDistributedVirtualSwitchStatus `json:"status,omitempty"`
}

// +kubebuilder:object:root=true

// VSphereDistributedVirtualSwitchList contains a list of VSphereDistributedVirtualSwitchs
type VSphereDistributedVirtualSwitchList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []VSphereDistributedVirtualSwitch `json:"items"`
}

// Repository type metadata.
var (
	VSphereDistributedVirtualSwitch_Kind             = "VSphereDistributedVirtualSwitch"
	VSphereDistributedVirtualSwitch_GroupKind        = schema.GroupKind{Group: CRDGroup, Kind: VSphereDistributedVirtualSwitch_Kind}.String()
	VSphereDistributedVirtualSwitch_KindAPIVersion   = VSphereDistributedVirtualSwitch_Kind + "." + CRDGroupVersion.String()
	VSphereDistributedVirtualSwitch_GroupVersionKind = CRDGroupVersion.WithKind(VSphereDistributedVirtualSwitch_Kind)
)

func init() {
	SchemeBuilder.Register(&VSphereDistributedVirtualSwitch{}, &VSphereDistributedVirtualSwitchList{})
}
