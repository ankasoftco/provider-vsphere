/*
Copyright 2022 Upbound Inc.
*/

// Code generated by upjet. DO NOT EDIT.

package v1alpha1

import (
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime/schema"

	v1 "github.com/crossplane/crossplane-runtime/apis/common/v1"
)

type VSphereDistributedPortGroupObservation struct {

	// List of active uplinks used for load balancing, matching the names of the uplinks assigned in the DVS.
	ActiveUplinks []*string `json:"activeUplinks,omitempty" tf:"active_uplinks,omitempty"`

	// Controls whether or not the virtual network adapter is allowed to send network traffic with a different MAC address than that of its own.
	AllowForgedTransmits *bool `json:"allowForgedTransmits,omitempty" tf:"allow_forged_transmits,omitempty"`

	// Controls whether or not the Media Access Control (MAC) address can be changed.
	AllowMacChanges *bool `json:"allowMacChanges,omitempty" tf:"allow_mac_changes,omitempty"`

	// Enable promiscuous mode on the network. This flag indicates whether or not all traffic is seen on a given port.
	AllowPromiscuous *bool `json:"allowPromiscuous,omitempty" tf:"allow_promiscuous,omitempty"`

	// Auto-expands the port group beyond the port count configured in number_of_ports when necessary.
	AutoExpand *bool `json:"autoExpand,omitempty" tf:"auto_expand,omitempty"`

	// Indicates whether to block all ports by default.
	BlockAllPorts *bool `json:"blockAllPorts,omitempty" tf:"block_all_ports,omitempty"`

	// Allow the blocked setting of an individual port to override the setting in the portgroup.
	BlockOverrideAllowed *bool `json:"blockOverrideAllowed,omitempty" tf:"block_override_allowed,omitempty"`

	// Enable beacon probing on the ports this policy applies to.
	CheckBeacon *bool `json:"checkBeacon,omitempty" tf:"check_beacon,omitempty"`

	// Version string of the configuration that this spec is trying to change.
	ConfigVersion *string `json:"configVersion,omitempty" tf:"config_version,omitempty"`

	// A list of custom attributes to set on this resource.
	CustomAttributes map[string]*string `json:"customAttributes,omitempty" tf:"custom_attributes,omitempty"`

	// The description of the portgroup.
	Description *string `json:"description,omitempty" tf:"description,omitempty"`

	// Allow VMDirectPath Gen2 on the ports this policy applies to.
	DirectpathGen2Allowed *bool `json:"directpathGen2Allowed,omitempty" tf:"directpath_gen2_allowed,omitempty"`

	// The UUID of the DVS to attach this port group to.
	DistributedVirtualSwitchUUID *string `json:"distributedVirtualSwitchUuid,omitempty" tf:"distributed_virtual_switch_uuid,omitempty"`

	// The average egress bandwidth in bits per second if egress shaping is enabled on the port.
	EgressShapingAverageBandwidth *float64 `json:"egressShapingAverageBandwidth,omitempty" tf:"egress_shaping_average_bandwidth,omitempty"`

	// The maximum egress burst size allowed in bytes if egress shaping is enabled on the port.
	EgressShapingBurstSize *float64 `json:"egressShapingBurstSize,omitempty" tf:"egress_shaping_burst_size,omitempty"`

	// True if the traffic shaper is enabled for egress traffic on the port.
	EgressShapingEnabled *bool `json:"egressShapingEnabled,omitempty" tf:"egress_shaping_enabled,omitempty"`

	// The peak egress bandwidth during bursts in bits per second if egress traffic shaping is enabled on the port.
	EgressShapingPeakBandwidth *float64 `json:"egressShapingPeakBandwidth,omitempty" tf:"egress_shaping_peak_bandwidth,omitempty"`

	// If true, the teaming policy will re-activate failed interfaces higher in precedence when they come back up.
	Failback *bool `json:"failback,omitempty" tf:"failback,omitempty"`

	ID *string `json:"id,omitempty" tf:"id,omitempty"`

	// The average ingress bandwidth in bits per second if ingress shaping is enabled on the port.
	IngressShapingAverageBandwidth *float64 `json:"ingressShapingAverageBandwidth,omitempty" tf:"ingress_shaping_average_bandwidth,omitempty"`

	// The maximum ingress burst size allowed in bytes if ingress shaping is enabled on the port.
	IngressShapingBurstSize *float64 `json:"ingressShapingBurstSize,omitempty" tf:"ingress_shaping_burst_size,omitempty"`

	// True if the traffic shaper is enabled for ingress traffic on the port.
	IngressShapingEnabled *bool `json:"ingressShapingEnabled,omitempty" tf:"ingress_shaping_enabled,omitempty"`

	// The peak ingress bandwidth during bursts in bits per second if ingress traffic shaping is enabled on the port.
	IngressShapingPeakBandwidth *float64 `json:"ingressShapingPeakBandwidth,omitempty" tf:"ingress_shaping_peak_bandwidth,omitempty"`

	// The generated UUID of the portgroup.
	Key *string `json:"key,omitempty" tf:"key,omitempty"`

	// Whether or not to enable LACP on all uplink ports.
	LacpEnabled *bool `json:"lacpEnabled,omitempty" tf:"lacp_enabled,omitempty"`

	// The uplink LACP mode to use. Can be one of active or passive.
	LacpMode *string `json:"lacpMode,omitempty" tf:"lacp_mode,omitempty"`

	// Allow a live port to be moved in and out of the portgroup.
	LivePortMovingAllowed *bool `json:"livePortMovingAllowed,omitempty" tf:"live_port_moving_allowed,omitempty"`

	// The name of the portgroup.
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// Indicates whether to enable netflow on all ports.
	NetflowEnabled *bool `json:"netflowEnabled,omitempty" tf:"netflow_enabled,omitempty"`

	// Allow the enabling or disabling of Netflow on a port, contrary to the policy in the portgroup.
	NetflowOverrideAllowed *bool `json:"netflowOverrideAllowed,omitempty" tf:"netflow_override_allowed,omitempty"`

	// The key of a network resource pool to associate with this portgroup.
	NetworkResourcePoolKey *string `json:"networkResourcePoolKey,omitempty" tf:"network_resource_pool_key,omitempty"`

	// Allow the network resource pool of an individual port to override the setting in the portgroup.
	NetworkResourcePoolOverrideAllowed *bool `json:"networkResourcePoolOverrideAllowed,omitempty" tf:"network_resource_pool_override_allowed,omitempty"`

	// If true, the teaming policy will notify the broadcast network of a NIC failover, triggering cache updates.
	NotifySwitches *bool `json:"notifySwitches,omitempty" tf:"notify_switches,omitempty"`

	// The number of ports in this portgroup. The DVS will expand and shrink by modifying this setting.
	NumberOfPorts *float64 `json:"numberOfPorts,omitempty" tf:"number_of_ports,omitempty"`

	// Reset the setting of any ports in this portgroup back to the default setting when the port disconnects.
	PortConfigResetAtDisconnect *bool `json:"portConfigResetAtDisconnect,omitempty" tf:"port_config_reset_at_disconnect,omitempty"`

	// A template string to use when creating ports in the portgroup.
	PortNameFormat *string `json:"portNameFormat,omitempty" tf:"port_name_format,omitempty"`

	// The secondary VLAN ID for this port.
	PortPrivateSecondaryVlanID *float64 `json:"portPrivateSecondaryVlanId,omitempty" tf:"port_private_secondary_vlan_id,omitempty"`

	// Allow security policy settings on a port to override those on the portgroup.
	SecurityPolicyOverrideAllowed *bool `json:"securityPolicyOverrideAllowed,omitempty" tf:"security_policy_override_allowed,omitempty"`

	// Allow the traffic shaping policies of an individual port to override the settings in the portgroup.
	ShapingOverrideAllowed *bool `json:"shapingOverrideAllowed,omitempty" tf:"shaping_override_allowed,omitempty"`

	// List of standby uplinks used for load balancing, matching the names of the uplinks assigned in the DVS.
	StandbyUplinks []*string `json:"standbyUplinks,omitempty" tf:"standby_uplinks,omitempty"`

	// A list of tag IDs to apply to this object.
	Tags []*string `json:"tags,omitempty" tf:"tags,omitempty"`

	// The network adapter teaming policy. Can be one of loadbalance_ip, loadbalance_srcmac, loadbalance_srcid, failover_explicit, or loadbalance_loadbased.
	TeamingPolicy *string `json:"teamingPolicy,omitempty" tf:"teaming_policy,omitempty"`

	// Allow any filter policies set on the individual port to override those in the portgroup.
	TrafficFilterOverrideAllowed *bool `json:"trafficFilterOverrideAllowed,omitempty" tf:"traffic_filter_override_allowed,omitempty"`

	// If true, a copy of packets sent to the switch will always be forwarded to an uplink in addition to the regular packet forwarded done by the switch.
	TxUplink *bool `json:"txUplink,omitempty" tf:"tx_uplink,omitempty"`

	// The type of portgroup. Can be one of earlyBinding (static) or ephemeral.
	Type *string `json:"type,omitempty" tf:"type,omitempty"`

	// Allow the uplink teaming policies on a port to override those on the portgroup.
	UplinkTeamingOverrideAllowed *bool `json:"uplinkTeamingOverrideAllowed,omitempty" tf:"uplink_teaming_override_allowed,omitempty"`

	// The VLAN ID for single VLAN mode. 0 denotes no VLAN.
	VlanID *float64 `json:"vlanId,omitempty" tf:"vlan_id,omitempty"`

	// Allow the VLAN configuration on a port to override those on the portgroup.
	VlanOverrideAllowed *bool `json:"vlanOverrideAllowed,omitempty" tf:"vlan_override_allowed,omitempty"`

	// The VLAN ID for single VLAN mode. 0 denotes no VLAN.
	VlanRange []VlanRangeObservation `json:"vlanRange,omitempty" tf:"vlan_range,omitempty"`
}

type VSphereDistributedPortGroupParameters struct {

	// List of active uplinks used for load balancing, matching the names of the uplinks assigned in the DVS.
	// +kubebuilder:validation:Optional
	ActiveUplinks []*string `json:"activeUplinks,omitempty" tf:"active_uplinks,omitempty"`

	// Controls whether or not the virtual network adapter is allowed to send network traffic with a different MAC address than that of its own.
	// +kubebuilder:validation:Optional
	AllowForgedTransmits *bool `json:"allowForgedTransmits,omitempty" tf:"allow_forged_transmits,omitempty"`

	// Controls whether or not the Media Access Control (MAC) address can be changed.
	// +kubebuilder:validation:Optional
	AllowMacChanges *bool `json:"allowMacChanges,omitempty" tf:"allow_mac_changes,omitempty"`

	// Enable promiscuous mode on the network. This flag indicates whether or not all traffic is seen on a given port.
	// +kubebuilder:validation:Optional
	AllowPromiscuous *bool `json:"allowPromiscuous,omitempty" tf:"allow_promiscuous,omitempty"`

	// Auto-expands the port group beyond the port count configured in number_of_ports when necessary.
	// +kubebuilder:validation:Optional
	AutoExpand *bool `json:"autoExpand,omitempty" tf:"auto_expand,omitempty"`

	// Indicates whether to block all ports by default.
	// +kubebuilder:validation:Optional
	BlockAllPorts *bool `json:"blockAllPorts,omitempty" tf:"block_all_ports,omitempty"`

	// Allow the blocked setting of an individual port to override the setting in the portgroup.
	// +kubebuilder:validation:Optional
	BlockOverrideAllowed *bool `json:"blockOverrideAllowed,omitempty" tf:"block_override_allowed,omitempty"`

	// Enable beacon probing on the ports this policy applies to.
	// +kubebuilder:validation:Optional
	CheckBeacon *bool `json:"checkBeacon,omitempty" tf:"check_beacon,omitempty"`

	// A list of custom attributes to set on this resource.
	// +kubebuilder:validation:Optional
	CustomAttributes map[string]*string `json:"customAttributes,omitempty" tf:"custom_attributes,omitempty"`

	// The description of the portgroup.
	// +kubebuilder:validation:Optional
	Description *string `json:"description,omitempty" tf:"description,omitempty"`

	// Allow VMDirectPath Gen2 on the ports this policy applies to.
	// +kubebuilder:validation:Optional
	DirectpathGen2Allowed *bool `json:"directpathGen2Allowed,omitempty" tf:"directpath_gen2_allowed,omitempty"`

	// The UUID of the DVS to attach this port group to.
	// +kubebuilder:validation:Optional
	DistributedVirtualSwitchUUID *string `json:"distributedVirtualSwitchUuid,omitempty" tf:"distributed_virtual_switch_uuid,omitempty"`

	// The average egress bandwidth in bits per second if egress shaping is enabled on the port.
	// +kubebuilder:validation:Optional
	EgressShapingAverageBandwidth *float64 `json:"egressShapingAverageBandwidth,omitempty" tf:"egress_shaping_average_bandwidth,omitempty"`

	// The maximum egress burst size allowed in bytes if egress shaping is enabled on the port.
	// +kubebuilder:validation:Optional
	EgressShapingBurstSize *float64 `json:"egressShapingBurstSize,omitempty" tf:"egress_shaping_burst_size,omitempty"`

	// True if the traffic shaper is enabled for egress traffic on the port.
	// +kubebuilder:validation:Optional
	EgressShapingEnabled *bool `json:"egressShapingEnabled,omitempty" tf:"egress_shaping_enabled,omitempty"`

	// The peak egress bandwidth during bursts in bits per second if egress traffic shaping is enabled on the port.
	// +kubebuilder:validation:Optional
	EgressShapingPeakBandwidth *float64 `json:"egressShapingPeakBandwidth,omitempty" tf:"egress_shaping_peak_bandwidth,omitempty"`

	// If true, the teaming policy will re-activate failed interfaces higher in precedence when they come back up.
	// +kubebuilder:validation:Optional
	Failback *bool `json:"failback,omitempty" tf:"failback,omitempty"`

	// The average ingress bandwidth in bits per second if ingress shaping is enabled on the port.
	// +kubebuilder:validation:Optional
	IngressShapingAverageBandwidth *float64 `json:"ingressShapingAverageBandwidth,omitempty" tf:"ingress_shaping_average_bandwidth,omitempty"`

	// The maximum ingress burst size allowed in bytes if ingress shaping is enabled on the port.
	// +kubebuilder:validation:Optional
	IngressShapingBurstSize *float64 `json:"ingressShapingBurstSize,omitempty" tf:"ingress_shaping_burst_size,omitempty"`

	// True if the traffic shaper is enabled for ingress traffic on the port.
	// +kubebuilder:validation:Optional
	IngressShapingEnabled *bool `json:"ingressShapingEnabled,omitempty" tf:"ingress_shaping_enabled,omitempty"`

	// The peak ingress bandwidth during bursts in bits per second if ingress traffic shaping is enabled on the port.
	// +kubebuilder:validation:Optional
	IngressShapingPeakBandwidth *float64 `json:"ingressShapingPeakBandwidth,omitempty" tf:"ingress_shaping_peak_bandwidth,omitempty"`

	// Whether or not to enable LACP on all uplink ports.
	// +kubebuilder:validation:Optional
	LacpEnabled *bool `json:"lacpEnabled,omitempty" tf:"lacp_enabled,omitempty"`

	// The uplink LACP mode to use. Can be one of active or passive.
	// +kubebuilder:validation:Optional
	LacpMode *string `json:"lacpMode,omitempty" tf:"lacp_mode,omitempty"`

	// Allow a live port to be moved in and out of the portgroup.
	// +kubebuilder:validation:Optional
	LivePortMovingAllowed *bool `json:"livePortMovingAllowed,omitempty" tf:"live_port_moving_allowed,omitempty"`

	// The name of the portgroup.
	// +kubebuilder:validation:Optional
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// Indicates whether to enable netflow on all ports.
	// +kubebuilder:validation:Optional
	NetflowEnabled *bool `json:"netflowEnabled,omitempty" tf:"netflow_enabled,omitempty"`

	// Allow the enabling or disabling of Netflow on a port, contrary to the policy in the portgroup.
	// +kubebuilder:validation:Optional
	NetflowOverrideAllowed *bool `json:"netflowOverrideAllowed,omitempty" tf:"netflow_override_allowed,omitempty"`

	// The key of a network resource pool to associate with this portgroup.
	// +kubebuilder:validation:Optional
	NetworkResourcePoolKey *string `json:"networkResourcePoolKey,omitempty" tf:"network_resource_pool_key,omitempty"`

	// Allow the network resource pool of an individual port to override the setting in the portgroup.
	// +kubebuilder:validation:Optional
	NetworkResourcePoolOverrideAllowed *bool `json:"networkResourcePoolOverrideAllowed,omitempty" tf:"network_resource_pool_override_allowed,omitempty"`

	// If true, the teaming policy will notify the broadcast network of a NIC failover, triggering cache updates.
	// +kubebuilder:validation:Optional
	NotifySwitches *bool `json:"notifySwitches,omitempty" tf:"notify_switches,omitempty"`

	// The number of ports in this portgroup. The DVS will expand and shrink by modifying this setting.
	// +kubebuilder:validation:Optional
	NumberOfPorts *float64 `json:"numberOfPorts,omitempty" tf:"number_of_ports,omitempty"`

	// Reset the setting of any ports in this portgroup back to the default setting when the port disconnects.
	// +kubebuilder:validation:Optional
	PortConfigResetAtDisconnect *bool `json:"portConfigResetAtDisconnect,omitempty" tf:"port_config_reset_at_disconnect,omitempty"`

	// A template string to use when creating ports in the portgroup.
	// +kubebuilder:validation:Optional
	PortNameFormat *string `json:"portNameFormat,omitempty" tf:"port_name_format,omitempty"`

	// The secondary VLAN ID for this port.
	// +kubebuilder:validation:Optional
	PortPrivateSecondaryVlanID *float64 `json:"portPrivateSecondaryVlanId,omitempty" tf:"port_private_secondary_vlan_id,omitempty"`

	// Allow security policy settings on a port to override those on the portgroup.
	// +kubebuilder:validation:Optional
	SecurityPolicyOverrideAllowed *bool `json:"securityPolicyOverrideAllowed,omitempty" tf:"security_policy_override_allowed,omitempty"`

	// Allow the traffic shaping policies of an individual port to override the settings in the portgroup.
	// +kubebuilder:validation:Optional
	ShapingOverrideAllowed *bool `json:"shapingOverrideAllowed,omitempty" tf:"shaping_override_allowed,omitempty"`

	// List of standby uplinks used for load balancing, matching the names of the uplinks assigned in the DVS.
	// +kubebuilder:validation:Optional
	StandbyUplinks []*string `json:"standbyUplinks,omitempty" tf:"standby_uplinks,omitempty"`

	// A list of tag IDs to apply to this object.
	// +kubebuilder:validation:Optional
	Tags []*string `json:"tags,omitempty" tf:"tags,omitempty"`

	// The network adapter teaming policy. Can be one of loadbalance_ip, loadbalance_srcmac, loadbalance_srcid, failover_explicit, or loadbalance_loadbased.
	// +kubebuilder:validation:Optional
	TeamingPolicy *string `json:"teamingPolicy,omitempty" tf:"teaming_policy,omitempty"`

	// Allow any filter policies set on the individual port to override those in the portgroup.
	// +kubebuilder:validation:Optional
	TrafficFilterOverrideAllowed *bool `json:"trafficFilterOverrideAllowed,omitempty" tf:"traffic_filter_override_allowed,omitempty"`

	// If true, a copy of packets sent to the switch will always be forwarded to an uplink in addition to the regular packet forwarded done by the switch.
	// +kubebuilder:validation:Optional
	TxUplink *bool `json:"txUplink,omitempty" tf:"tx_uplink,omitempty"`

	// The type of portgroup. Can be one of earlyBinding (static) or ephemeral.
	// +kubebuilder:validation:Optional
	Type *string `json:"type,omitempty" tf:"type,omitempty"`

	// Allow the uplink teaming policies on a port to override those on the portgroup.
	// +kubebuilder:validation:Optional
	UplinkTeamingOverrideAllowed *bool `json:"uplinkTeamingOverrideAllowed,omitempty" tf:"uplink_teaming_override_allowed,omitempty"`

	// The VLAN ID for single VLAN mode. 0 denotes no VLAN.
	// +kubebuilder:validation:Optional
	VlanID *float64 `json:"vlanId,omitempty" tf:"vlan_id,omitempty"`

	// Allow the VLAN configuration on a port to override those on the portgroup.
	// +kubebuilder:validation:Optional
	VlanOverrideAllowed *bool `json:"vlanOverrideAllowed,omitempty" tf:"vlan_override_allowed,omitempty"`

	// The VLAN ID for single VLAN mode. 0 denotes no VLAN.
	// +kubebuilder:validation:Optional
	VlanRange []VlanRangeParameters `json:"vlanRange,omitempty" tf:"vlan_range,omitempty"`
}

type VlanRangeObservation struct {

	// The minimum VLAN to use in the range.
	MaxVlan *float64 `json:"maxVlan,omitempty" tf:"max_vlan,omitempty"`

	// The minimum VLAN to use in the range.
	MinVlan *float64 `json:"minVlan,omitempty" tf:"min_vlan,omitempty"`
}

type VlanRangeParameters struct {

	// The minimum VLAN to use in the range.
	// +kubebuilder:validation:Required
	MaxVlan *float64 `json:"maxVlan" tf:"max_vlan,omitempty"`

	// The minimum VLAN to use in the range.
	// +kubebuilder:validation:Required
	MinVlan *float64 `json:"minVlan" tf:"min_vlan,omitempty"`
}

// VSphereDistributedPortGroupSpec defines the desired state of VSphereDistributedPortGroup
type VSphereDistributedPortGroupSpec struct {
	v1.ResourceSpec `json:",inline"`
	ForProvider     VSphereDistributedPortGroupParameters `json:"forProvider"`
}

// VSphereDistributedPortGroupStatus defines the observed state of VSphereDistributedPortGroup.
type VSphereDistributedPortGroupStatus struct {
	v1.ResourceStatus `json:",inline"`
	AtProvider        VSphereDistributedPortGroupObservation `json:"atProvider,omitempty"`
}

// +kubebuilder:object:root=true

// VSphereDistributedPortGroup is the Schema for the VSphereDistributedPortGroups API. <no value>
// +kubebuilder:printcolumn:name="READY",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="SYNCED",type="string",JSONPath=".status.conditions[?(@.type=='Synced')].status"
// +kubebuilder:printcolumn:name="EXTERNAL-NAME",type="string",JSONPath=".metadata.annotations.crossplane\\.io/external-name"
// +kubebuilder:printcolumn:name="AGE",type="date",JSONPath=".metadata.creationTimestamp"
// +kubebuilder:subresource:status
// +kubebuilder:resource:scope=Cluster,categories={crossplane,managed,vsphere}
type VSphereDistributedPortGroup struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	// +kubebuilder:validation:XValidation:rule="self.managementPolicy == 'ObserveOnly' || has(self.forProvider.distributedVirtualSwitchUuid)",message="distributedVirtualSwitchUuid is a required parameter"
	// +kubebuilder:validation:XValidation:rule="self.managementPolicy == 'ObserveOnly' || has(self.forProvider.name)",message="name is a required parameter"
	Spec   VSphereDistributedPortGroupSpec   `json:"spec"`
	Status VSphereDistributedPortGroupStatus `json:"status,omitempty"`
}

// +kubebuilder:object:root=true

// VSphereDistributedPortGroupList contains a list of VSphereDistributedPortGroups
type VSphereDistributedPortGroupList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []VSphereDistributedPortGroup `json:"items"`
}

// Repository type metadata.
var (
	VSphereDistributedPortGroup_Kind             = "VSphereDistributedPortGroup"
	VSphereDistributedPortGroup_GroupKind        = schema.GroupKind{Group: CRDGroup, Kind: VSphereDistributedPortGroup_Kind}.String()
	VSphereDistributedPortGroup_KindAPIVersion   = VSphereDistributedPortGroup_Kind + "." + CRDGroupVersion.String()
	VSphereDistributedPortGroup_GroupVersionKind = CRDGroupVersion.WithKind(VSphereDistributedPortGroup_Kind)
)

func init() {
	SchemeBuilder.Register(&VSphereDistributedPortGroup{}, &VSphereDistributedPortGroupList{})
}
